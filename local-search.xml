<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>编译原理判断LL、LR、SLR</title>
    <link href="/2022/01/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%88%A4%E6%96%ADLL%E3%80%81LR%E3%80%81SLR/"/>
    <url>/2022/01/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%88%A4%E6%96%ADLL%E3%80%81LR%E3%80%81SLR/</url>
    
    <content type="html"><![CDATA[<p><img src="Page1.png">  </p><p><img src="Page2.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
      <category>语法分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见语句的文法</title>
    <link href="/2022/01/07/%E5%B8%B8%E8%A7%81%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%96%87%E6%B3%95/"/>
    <url>/2022/01/07/%E5%B8%B8%E8%A7%81%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%96%87%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>program -&gt; stmt-sequence<br>stmt-sequence -&gt; statement { ; statement }<br>statement -&gt; if-stmt | repeat-stmt | assign-stmt | read-stmt | dowrite-stmt | for-stmt<br>if-stmt -&gt; if (bool-exp) then stmt-sequence [else stmt-sequence] end<br>repeat-stmt -&gt; repeat stmt-sequence until bool-exp<br>dowrite-stmt -&gt; do  stmt-sequence  while(bool-exp);<br>for-stmt–&gt;for assign-stmt  to  simple-exp  do  stmt-sequence enddo | for assign-stmt  downto  simple-exp  do  stmt-sequence enddo<br>assign-stmt -&gt; identifier [-]= exp | identifier := regex-exp<br>read-stmt -&gt; read identifier<br>write-stmt -&gt; write exp<br>exp -&gt; simple-exp [comparison-op simple-exp]<br>comparison-op -&gt;  &lt; | &gt; | &gt;= | &lt;= | &lt;&gt; | ==<br>simple-exp -&gt; term { addop term }<br>addop -&gt; + | -<br>term -&gt; pow_term{ mulop pow_term}</p><p>bool-exp -&gt; bterm { or bterm }<br>bterm -&gt; cterm{ and  cterm}<br>cterm -&gt; [not ] eterm<br>eterm -&gt; exp | ( bool-exp )</p><p>regex-exp -&gt; regex1 {| regex1 }<br>regex1 -&gt; regex2 {&amp;  regex2 }<br>regex2 -&gt; regex3 [#]<br>regex3 -&gt;  identifier | (regex-exp)</p><p>mulop -&gt; * | / | %<br>pow_term-&gt; factor { ^  factor  }<br>factor -&gt;  (exp) | number | identifier</p>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
      <category>语法分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件工程</title>
    <link href="/2022/01/02/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    <url>/2022/01/02/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h1><h2 id="软件的概念"><a href="#软件的概念" class="headerlink" title="软件的概念"></a>软件的概念</h2><p>程序+数据+文档</p><h2 id="软件工程是什么？"><a href="#软件工程是什么？" class="headerlink" title="软件工程是什么？"></a>软件工程是什么？</h2><p>以工程化的方法开发软件，软件工程即用工程、科学和数学的原则和方法研制、维护计算机软件的有关技术及方法，其优点是以较小的代价开发高质量的软件并有效地维护它。</p><h2 id="软件工程学概述"><a href="#软件工程学概述" class="headerlink" title="软件工程学概述"></a>软件工程学概述</h2><h3 id="软件危机"><a href="#软件危机" class="headerlink" title="软件危机"></a>软件危机</h3><p>软件危机指在计算机软件的<strong>开发</strong>和<strong>维护</strong>过程中，所遇到的一系列严重问题。</p><ol><li>软件开发的预算和时间不可预测(不可控)</li><li>软件质量得不到保证(不可用)</li><li>维护非常困难(不可维护)  </li></ol><p>按工程化的原则和方法组织软件开发工作是有效的，是摆脱软件危机的一个主要方法。</p><h3 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h3><h4 id="软件工程是什么？-1"><a href="#软件工程是什么？-1" class="headerlink" title="软件工程是什么？"></a>软件工程是什么？</h4><p>研究和应用如何以系统性、规范化的、可定量的过程化方法，以及如何把经过实践验证而证明正确的管理技术和当前能够得到最好的技术方法结合起来</p><h4 id="软件工程方法学"><a href="#软件工程方法学" class="headerlink" title="软件工程方法学"></a>软件工程方法学</h4><p><strong>软件工程方法学三要素：工具、方法和过程</strong>——</p><h4 id="软件工程方法学思想"><a href="#软件工程方法学思想" class="headerlink" title="软件工程方法学思想"></a>软件工程方法学思想</h4><ol><li>结构化方法（生命周期方法学或结构化方法）</li><li>面向对象方法</li><li>面向构件(服务)</li><li>敏捷方法</li></ol><h3 id="软件生命周期"><a href="#软件生命周期" class="headerlink" title="软件生命周期"></a>软件生命周期</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>指软件孕育、诞生、成长、成熟、衰亡的生存过程<br>一般有五个阶段：需求定义、设计、编码、测试及维护</p><h4 id="软件生命周期模型"><a href="#软件生命周期模型" class="headerlink" title="软件生命周期模型"></a>软件生命周期模型</h4><p>重点！<br><strong>瀑布模型、快速原型模型、增量模型、螺旋模型、喷泉模型、RUP、敏捷过程等</strong></p><h3 id="软件过程"><a href="#软件过程" class="headerlink" title="软件过程"></a>软件过程</h3><p>为了获得高质量软件所需要完成的一系列任务的框架，它规定了完成各项任务的工作步骤。</p><h1 id="可行性研究"><a href="#可行性研究" class="headerlink" title="可行性研究"></a>可行性研究</h1><h2 id="系统流程图（不是程序流程图）"><a href="#系统流程图（不是程序流程图）" class="headerlink" title="系统流程图（不是程序流程图）"></a>系统流程图（不是程序流程图）</h2><h2 id="数据流图"><a href="#数据流图" class="headerlink" title="数据流图"></a>数据流图</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>数据流图拥有的成分：源点/终点、处理、数据存储、数据流</strong><br>数据流图只考虑必须完成的逻辑功能 (“做什么”), 而不考虑如何实现这些功能(“怎么做”)。</p><p>数据流图是重点中的重点，详细画法一定要上网搜索别的博客！（或者查书）</p><h3 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h3><h2 id="成本分析"><a href="#成本分析" class="headerlink" title="成本分析"></a>成本分析</h2><h3 id="代码行"><a href="#代码行" class="headerlink" title="代码行"></a>代码行</h3><p>代码行方法：根据经验和历史数据，估算实现一个功能需要多少源程序行数，用每行代码的平均成本乘以行数。</p><h3 id="功能点"><a href="#功能点" class="headerlink" title="功能点"></a>功能点</h3><p>略</p><h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><ol><li>基本任务：回答必须做什么</li><li>三种模型：数据模型（实体联系图）、功能模型（数据流图）、行为模型（状态转换图）</li><li>三个阶段<br> a. 需求获取阶段（问题分析）<br> b. 需求规约/规格说明阶段（需求描述）<br> c. 需求验证阶段（需求评审）</li></ol><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>需求分析的任务：</p><ol><li>确定对系统的综合要求：P56<br>功能需求、性能需求、运行要求、未来可能的扩充要求等</li><li>分析系统的数据要求：P57<br> a. 建立概念模型( ER 图)<br> b. 形象描绘数据结构( 层次方框图、Warnier 图、IPO图)<br> c. 数据结构规范化</li><li>导出系统的逻辑模型: P58</li><li>修正系统开发计划：重估成本、进度</li><li>开发原型系统</li></ol><h1 id="总体设计"><a href="#总体设计" class="headerlink" title="总体设计"></a>总体设计</h1><h2 id="总体设计概念及任务-常用的软件体系结构"><a href="#总体设计概念及任务-常用的软件体系结构" class="headerlink" title="总体设计概念及任务(常用的软件体系结构)"></a>总体设计概念及任务(常用的软件体系结构)</h2><p>根据软件需求，设计软件系统结构和数据结构，确定程序的组成模块及模块之间的相互关系<br>① 制定规范。接口规约、编码规范、界面规范、数据库设计规范等。<br>② 设计软件系统结构（简称体系结构）（模块划分、模块功能、模块接口、质量评估）<br>③ 数据结构及数据库设计 （根据ER图和DD设计具体数据结构）<br>④ 接口设计(包括界面设计）<br>⑤ 编写概要设计文档<br>⑥ 概要设计评审</p><h2 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h2><h2 id="启发规则"><a href="#启发规则" class="headerlink" title="启发规则"></a>启发规则</h2><h2 id="描绘软件结构的图形工具"><a href="#描绘软件结构的图形工具" class="headerlink" title="描绘软件结构的图形工具"></a>描绘软件结构的图形工具</h2><h2 id="面向数据流的设计方法"><a href="#面向数据流的设计方法" class="headerlink" title="面向数据流的设计方法"></a>面向数据流的设计方法</h2><h2 id="概要设计说明书"><a href="#概要设计说明书" class="headerlink" title="概要设计说明书"></a>概要设计说明书</h2><h1 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h1><h2 id="对象模型"><a href="#对象模型" class="headerlink" title="对象模型"></a>对象模型</h2><p>类图</p><h2 id="动态模型"><a href="#动态模型" class="headerlink" title="动态模型"></a>动态模型</h2><p>状态图</p><h2 id="功能模型"><a href="#功能模型" class="headerlink" title="功能模型"></a>功能模型</h2><p>用例图</p>]]></content>
    
    
    <categories>
      
      <category>软件工程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文法问题处理器</title>
    <link href="/2022/01/02/%E6%96%87%E6%B3%95%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86%E5%99%A8/"/>
    <url>/2022/01/02/%E6%96%87%E6%B3%95%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="文法公式"><a href="#文法公式" class="headerlink" title="文法公式"></a>文法公式</h1><figure class="highlight ini"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">G</span> = (VT , VN , P , S)<br></code></pre></div></td></tr></table></figure><h2 id="VT-终结符集合"><a href="#VT-终结符集合" class="headerlink" title="VT 终结符集合"></a>VT 终结符集合</h2><p>终结符是不可以再推导的字符，表现形式是终结符不能出现在产生式左边</p><h2 id="非终结符"><a href="#非终结符" class="headerlink" title="非终结符"></a>非终结符</h2><p>非终结符是可以继续推导的字符</p><h2 id="产生式集合"><a href="#产生式集合" class="headerlink" title="产生式集合"></a>产生式集合</h2><p>形如：E-&gt;e的产生式集合</p><h2 id="开始符号"><a href="#开始符号" class="headerlink" title="开始符号"></a>开始符号</h2><p>文法的开始符号，一般为S</p><h1 id="文法的分类"><a href="#文法的分类" class="headerlink" title="文法的分类"></a>文法的分类</h1><h2 id="0型文法"><a href="#0型文法" class="headerlink" title="0型文法"></a>0型文法</h2><p>又被称为无限制文法(Unrestricted Grammar), 或者短语结构文法（Phrase Structure Grammar）<br>定义: 对于产生式 α→β ，α 至少包含一个非终结符。<br>即 α,β∈(VN∪VT)* , α 和 β 都是文法符合串，并且 α 文法符合串中必须包含一个非终结符。<br>例如: aA→0bB; A0→11bB; 其中 (a,0,b∈VT),(A,B∈VN)。</p><h2 id="1型文法"><a href="#1型文法" class="headerlink" title="1型文法"></a>1型文法</h2><p>又被称为上下文有关文法(Context-Sensitive Grammar)<br>定义：对于产生式 α→β , |α| &lt;= |β|, 仅仅 S→ε 除外。|α| 表示 α 这个文法符合串中字符个数。例如 aAb 这个字符个数就是3个。<br>也就是说1型文法要求产生式右部文法符合串β 的字符个数要不小于产生式左部文法符合串α 的字符个数；但是空产生式(S→ε) 除外。一般情况下，这种产生式的形式为 α1Aα2→α1βα2，其中 α1,α2,β∈(VN∪VT)*, β≠ε，A∈VN。<br>所以对于非终结符 A, 出现在 α1 和 α2 上下文中，就可以替换成文法符号串β 。</p><h2 id="2型文法"><a href="#2型文法" class="headerlink" title="2型文法"></a>2型文法</h2><p>又被称为上下文无关文法(Context-Free Grammar)<br>定义：对任一产生式 α→β，都有 α∈VN，β∈(VN∪VT)*<br>对产生式左部进行了限制，α 就是非终结符集合 VN 中一个字符元素。<br>当然一个非终结符也是一个特殊的文法符号串，串中只有一个字符，且是一个非终结符。<br>β∈(VN∪VT)*, β 表示一个文法符号串，其中空串 ε 也是一个特殊文法符号串。<br>所以对于2型文法也有空产生式 (S→ε)<br>为什么叫上下文无关文法？因为对于任何一个非终结符 A (即 A∈VN)，可以直接根据产生式替换成一个文法符号串，而不需要特殊的上下文环境。</p><h2 id="3型文法"><a href="#3型文法" class="headerlink" title="3型文法"></a>3型文法</h2><p>又被称为正则文法（Regular Grammar，RG），分为右线性（Right Linear）文法和左线性（Left Linear）文法。<br>定义: 对任一产生式 α→β，都有 α∈VN，β最多两个字符元素，如果有二个字符必须是（终结符+非终结符）的格式，如果是一个字符，那么必须是终结符。</p><ol><li>右线性文法: A→bB 或者 A→b</li><li>左线性文法: A→Bb 或者 A→b</li></ol><h1 id="文法问题处理器"><a href="#文法问题处理器" class="headerlink" title="文法问题处理器"></a>文法问题处理器</h1><h2 id="去除左公因子"><a href="#去除左公因子" class="headerlink" title="去除左公因子"></a>去除左公因子</h2><h3 id="直接左公因子"><a href="#直接左公因子" class="headerlink" title="直接左公因子"></a>直接左公因子</h3><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc">&#x27;&#x27;&#x27;<br>对于非终结符 S，它对应的候选式(即产生式)有相同前缀 a, 当我们要替换 S 的时候，就不知道该选择那一个候选式，因此我们要消除这种情况。<br>&#x27;&#x27;&#x27;<br>S -&gt; aAc | aBd<br><br>&#x27;&#x27;&#x27;<br>于是我们需要对它进行一定的变形<br>&#x27;&#x27;&#x27;<br>S-&gt;aAd|aBc|cC|d<br>#变成<br>S-&gt;aS&#x27;|cC|d<br>S&#x27;-&gt;Ad|Bc<br></code></pre></div></td></tr></table></figure><p><strong>但是，还有间接左公因子、以及多个前缀相同的产生式！</strong></p><h3 id="间接左公因子"><a href="#间接左公因子" class="headerlink" title="间接左公因子"></a>间接左公因子</h3><p>假如，对于如下文法，就会产生一个间接的左公因子。如果对于first(aaB)和first(An)，有相同的first集合，那么他们就有相同的左公因子。需要进行代入后，按照消除直接左公因子的方式消除掉</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">S<span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>aaB<span class="hljs-operator">|</span>An<br>A<span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>an<br></code></pre></div></td></tr></table></figure><h3 id="多前缀相同的产生式"><a href="#多前缀相同的产生式" class="headerlink" title="多前缀相同的产生式"></a>多前缀相同的产生式</h3><h2 id="去除左递归"><a href="#去除左递归" class="headerlink" title="去除左递归"></a>去除左递归</h2><h2 id="first、follow和select"><a href="#first、follow和select" class="headerlink" title="first、follow和select"></a>first、follow和select</h2><h3 id="first"><a href="#first" class="headerlink" title="first"></a>first</h3><h4 id="串首终结符集（First）"><a href="#串首终结符集（First）" class="headerlink" title="串首终结符集（First）"></a>串首终结符集（First）</h4><p>定义：给定一个文法符号α，α的串首终结符集First(α)被定义为可以从α推导出的所有串首终结符构成的集合。<br>串首终结符意思就是符号串的首字符是终结符，所以由 α 推导出的所有首字母是终结符的文法符号串，这些终结符首字母组成的集合就是FIRST(α)。</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>例如一个文法符号串 BCDe, 其中 B C D 都是非终结符，e 是终结符。</p><ol><li>求产生式右侧BCDe的First集合，首先要求出B能推导多少个串首终结符。这个就要求出First(B)</li><li>如果B能够推出空串ε，即B-&gt;ε，那么B就是可以消除的，文法符号串BCDe相当于CDe，所以又要求First(C).</li><li>如此循环往复。</li></ol><h4 id="因此对于一个文法符号串-X1X2-…-Xn，求解串首终结符集-FIRST-X1X2-…-Xn-算法"><a href="#因此对于一个文法符号串-X1X2-…-Xn，求解串首终结符集-FIRST-X1X2-…-Xn-算法" class="headerlink" title="因此对于一个文法符号串 X1X2 … Xn，求解串首终结符集 FIRST(X1X2 … Xn)算法"></a>因此对于一个文法符号串 X1X2 … Xn，求解串首终结符集 FIRST(X1X2 … Xn)算法</h4><ol><li>遍历这个文法符号串，然后判断当前文法符号串中的字符 Xi (i属于1到n)。</li><li>如果 Xi 是终结符，那么它的串首终结符集FIRST(Xi)中就只有它自己，将FIRST(Xi)加入FIRST(X1X2 … Xn) 中；因为FIRST(Xi)也不可能包含空串 ε，不用再向下遍历，循环到此为止，得到最终的串首终结符集FIRST(X1X2 … Xn)。</li><li>如果 Xi 是非终结符，那么就将它的串首终结符集FIRST(Xi)加入FIRST(X1X2 … Xn) 中。</li></ol><ul><li>如果FIRST(Xi)包含空串ε，那么再向下遍历一个字符；但是如果 Xi 已经是最后一个字符了，那就说明整个文法符号串 X1X2 … Xn可以推导出空串ε，因此将空串ε加到FIRST(X1X2 … Xn) 中。</li><li>如果FIRST(Xi)不包含空串ε，不用再向下遍历，循环到此为止，得到最终的串首终结符集FIRST(X1X2 … Xn)。如求非终结符A 的串首终结符集FIRST(A)，其实就是看这个非终结符A 能够推导的所有首字符是终结符的文法符号串，那么就是看这个非终结符A 的产生式组。</li></ul><h4 id="非终结符本身就属于一个特殊的文法符号串"><a href="#非终结符本身就属于一个特殊的文法符号串" class="headerlink" title="非终结符本身就属于一个特殊的文法符号串"></a>非终结符本身就属于一个特殊的文法符号串</h4><p>而求解文法符号串的串首终结符集，其实就是要知道文法符号串中每个字符的串首终结符集:</p><ol><li>对于终结符，它的串首终结符集就是它自己。</li><li>对于非终结符，它的串首终结符集是要通过它对应的产生式组计算得来的。</li><li>再判断当前字符对应的串首终结符集包不包含空串，来决定要不要添加文法符号串中下一个字符的串首终结符集。</li></ol><h3 id="follow"><a href="#follow" class="headerlink" title="follow"></a>follow</h3><p>定义：对于任一非终结符A，它的后继符号集就是由文法G推导出来的所有句型，可以出现在非终结符A后边的终结符的集合，记为FOLLOW(A)。</p><h4 id="求非终结符A的后继符号集算法："><a href="#求非终结符A的后继符号集算法：" class="headerlink" title="求非终结符A的后继符号集算法："></a>求非终结符A的后继符号集算法：</h4><ol><li>遍历文法所有的产生式，判断产生式右部中是否包含非终结符A</li><li>S -&gt; αAβ : 包含非终结符A，其中 α 和 β 都属于文法符号串，那么就将文法符号串β 的串首终结符集FIRST(β) 中除了空串ε外的所有终结符添加到FOLLOW(A)。如果FIRST(β)存在空串ε，那么就需要将FOLLOW(S) 也添加到FOLLOW(A)中。</li><li>S -&gt; αA : 包含非终结符A, 其中 α 属于文法符号串，那么将FOLLOW(S) 添加到FOLLOW(A)中。<br>如果非终结符 A 是产生式结尾，那么说明这个产生式左部非终结符后面能出现的终结符，也都可以出现在非终结符 A后面。</li><li>刚开始的时候，需要将结束符号 $ 添加到文法开始符号S 的后继符号集FOLLOW(S) 中。</li><li>后继符号集中是不会包含空串ε的。</li></ol><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><ol><li>A→aβ : a 是终结符，β 是文法符号串，那么这个产生式的可选集SELECT(A→aβ) 就是这个终结符，即{a}。</li><li>A→ε : 空产生式对应的可选集SELECT(A→ε) 就是A的后继符号集，即 FOLLOW(A)。</li><li>A→Bβ : B 是非终结符，β 是文法符号串，那么这个产生式的可选集SELECT(A→Bβ) 就是文法符号串Bβ的串首终结符集，即FIRST(Bβ)。<br>注意，如果FIRST(Bβ)包含空串ε，即文法符号串Bβ能推导出空串ε，那么还要将Follow(A)添加到产生式对应的可选集中。</li></ol>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
      <category>语法分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式转NFA转DFA转最小化DFA</title>
    <link href="/2022/01/02/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%ACNFA%E8%BD%ACDFA%E8%BD%AC%E6%9C%80%E5%B0%8F%E5%8C%96DFA/"/>
    <url>/2022/01/02/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%ACNFA%E8%BD%ACDFA%E8%BD%AC%E6%9C%80%E5%B0%8F%E5%8C%96DFA/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qq_42256538/article/details/83719733">链接跳转，请看他的文章！</a></p><h1 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h1><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-keyword">String</span> s=<span class="hljs-string">&quot;(a|b)*&amp;a&amp;b&amp;b&quot;</span><br>Stack&lt;Character&gt; stack=<span class="hljs-keyword">new</span> Stack&lt;&gt;();<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;<br>    <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span>(s.<span class="hljs-built_in">at</span>(i))&#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span>:<br>            stack.<span class="hljs-built_in">push</span>(s.<span class="hljs-built_in">at</span>(i));<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;)&#x27;</span>:<br>            <span class="hljs-keyword">char</span> c;<br>            <span class="hljs-keyword">while</span>(c=stack.<span class="hljs-built_in">pop</span>()!=<span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                s+=c;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">if</span>(stack.<span class="hljs-built_in">isEmpty</span>())&#123;<br>                stack.<span class="hljs-built_in">push</span>(s.<span class="hljs-built_in">at</span>(i));<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">while</span>(<span class="hljs-built_in">pri</span>(stack.<span class="hljs-built_in">get</span>()&gt;=s.<span class="hljs-built_in">at</span>(i))&#123;<br>                    s+=stack.<span class="hljs-built_in">pop</span>();<br>                &#125;<br>            &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Edge</span>()</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> from;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> to;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">static</span> class <span class="hljs-title">Utils</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">Set&lt;Integer&gt; <span class="hljs-title">getSameStatus</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>&#123;<br>        Set&lt;Integer&gt; set=<span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>        NFA nfanode=NFAGraph.get(id);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nfanode.edges.size();i++)&#123;<br>            <span class="hljs-comment">//遍历所有边，如果找到边为空的就加入这个集合</span><br>            <span class="hljs-keyword">if</span>(nfanode.edges[i]==epsilon)&#123;<br>                set.add(nfanode.edges[i].to);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> set;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NFA</span></span>&#123;<br>    <span class="hljs-keyword">int</span> begin;<br>    <span class="hljs-keyword">int</span> end;<br>    List&lt;Edge&gt; edges;<br>    Set&lt;Integer&gt; sameStatus;<span class="hljs-comment">//存放相同状态的结点（弧为空的点）</span><br><br>    addEdges(<span class="hljs-keyword">int</span> begin,<span class="hljs-keyword">int</span> end)&#123;<span class="hljs-comment">//默认插入空&#125;</span><br>    addEdges(<span class="hljs-keyword">int</span> begin,<span class="hljs-keyword">int</span> end,<span class="hljs-keyword">char</span> a)&#123;<span class="hljs-comment">//……&#125;</span><br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br>Stack&lt;NFA&gt; NFAStack=<span class="hljs-keyword">new</span> Stack();<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s.size();i++)&#123;<br>    <span class="hljs-comment">//扫描这个转化之后的字符串</span><br>    <span class="hljs-keyword">if</span>(s.at(i).isAlpha())&#123;<br>        <span class="hljs-comment">//普通字母</span><br>        NFA nfanode=<span class="hljs-keyword">new</span> NFA(i++,i++);<br>        nfanode.addEdge(nfanode.begin,nfanode.end,s.at(i));<br>        stack.push(nfanode);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.at(i)==<span class="hljs-string">&#x27;|&#x27;</span>)&#123;<br>        NFA nfanode1=stack.pop();<br>        NFA nfanode2=stack.pop();<br>        NFA nfanode=<span class="hljs-keyword">new</span> NFA(i++,i++);<br>        <span class="hljs-comment">//插入边</span><br>        nfanode.addEdge(nfanode.begin,nfanode1.begin);<br>        nfanode.addEdge(nfanode.begin,nfanode2.begin)<br>        nfanode1.addEdge(nfanode1.begin,nfanode.end)<br>        nfanode2.addEdge(nfanode2.begin,nfanode.end)<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.at(i)==<span class="hljs-string">&#x27;&amp;&#x27;</span>)&#123;<br>        NFA nfanode1=stack.pop();<br>        NFA nfanode2=stack.pop();<br>        nfanode1.addEdge(nfanod1.end,nfanode2.begin);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.at(i)==<span class="hljs-string">&#x27;*&#x27;</span>)&#123;<br>        NFA nfanode1=stack.pop();<br>        NFA nfanode=<span class="hljs-keyword">new</span> NFA(i++,i++);<br>        nfanode.addEdge(nfanode.begin,nfanode.end);<br>        nfanode.addEdge(nfanode.begin,nfanode1.end);<br>        nfanode1.addEdge(nfanode1.end,nfanode.end);<br>        nfanode1.addEdge(nfanode1.begin,nfanode.begin);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//暴力填表法</span><br><span class="hljs-keyword">while</span>(!stack.isEmpty()) &#123;<br>    nextSameStatusNodesSet=stack.pop();<br>    HashMap&lt;String,Set&lt;NFANode&gt;&gt; NextLabelsAndNodeHashMap=nfaGraph.getNextLabelsAndNodeSet(nextSameStatusNodesSet);<br>    <span class="hljs-keyword">for</span>(String label:NextLabelsAndNodeHashMap.keySet()) &#123;<br>        <span class="hljs-keyword">if</span>(!nodeTable.containsValue(NextLabelsAndNodeHashMap.get(label))) &#123;<br>            nodeTable.put(NFA2DFA.ID++, NextLabelsAndNodeHashMap.get(label));<br>            stack.push(NextLabelsAndNodeHashMap.get(label));<br>        &#125;<br>    &#125;<br>    DFATable.put(nextSameStatusNodesSet,NextLabelsAndNodeHashMap);<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
      <category>词法分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>oracle数据库教程</title>
    <link href="/2021/12/24/oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%99%E7%A8%8B/"/>
    <url>/2021/12/24/oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.oraclejsq.com/">oracle教程</a></p>]]></content>
    
    
    <categories>
      
      <category>oracle数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>oracle数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java后端学习路线</title>
    <link href="/2021/12/20/java%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    <url>/2021/12/20/java%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="编程基础（掌握）"><a href="#编程基础（掌握）" class="headerlink" title="编程基础（掌握）"></a>编程基础（掌握）</h2><h3 id="JAVA语法"><a href="#JAVA语法" class="headerlink" title="JAVA语法"></a>JAVA语法</h3><h4 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h4><h4 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h4><ul><li>类加载机制</li><li>字节码执行机制</li><li>JVM内存模型</li><li>GC垃圾回收</li><li>JVM性能监控与故障定位</li><li>JVM调优</li></ul><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><ul><li>并发编程的基础</li><li>线程池</li><li>锁</li><li>并发容器</li><li>原子类</li><li>JUC并发工具类</li></ul><h3 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ul><li>字符串</li><li>数组</li><li>链表</li><li>堆、栈、队列</li><li>二叉树</li><li>哈希</li><li>图</li></ul><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><ul><li>排序</li><li>查找</li><li>贪心</li><li>分治</li><li>动态规划</li><li>回溯</li></ul><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><ul><li>ARP协议</li><li>IP、ICMP协议</li><li>TCP、UDP协议</li><li>DNS、HTTP/HTTPS协议</li><li>Session/Cookie</li></ul><h3 id="MySQL数据库"><a href="#MySQL数据库" class="headerlink" title="MySQL数据库"></a>MySQL数据库</h3><ul><li>SQL语句的书写</li><li>SQL语句的优化</li><li>事务、隔离级别</li><li>索引</li><li>锁</li></ul><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><ul><li>进程、线程</li><li>并发、锁</li><li>内存管理和调度</li><li>I/O原理</li></ul><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ul><li>单例</li><li>工厂</li><li>代理</li><li>策略</li><li>模板方法</li><li>观察者</li><li>适配器</li><li>责任链</li><li>建造者</li></ul><h2 id="研发工具"><a href="#研发工具" class="headerlink" title="研发工具"></a>研发工具</h2><h3 id="集成开发环境"><a href="#集成开发环境" class="headerlink" title="集成开发环境"></a>集成开发环境</h3><ul><li>Eclipse</li><li>Intellij IDEA</li><li>VSCode</li></ul><h3 id="Linux系统（了解）"><a href="#Linux系统（了解）" class="headerlink" title="Linux系统（了解）"></a>Linux系统（了解）</h3><ul><li>常用命令</li><li>Shell脚本</li></ul><h3 id="项目管理-构建工具（掌握）"><a href="#项目管理-构建工具（掌握）" class="headerlink" title="项目管理/构建工具（掌握）"></a>项目管理/构建工具（掌握）</h3><ul><li>Maven</li><li>Gradle</li></ul><h3 id="代码管理工具（了解）"><a href="#代码管理工具（了解）" class="headerlink" title="代码管理工具（了解）"></a>代码管理工具（了解）</h3><ul><li>SVN</li><li>Git</li></ul><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><h4 id="Spring家族框架（掌握-2-3month）"><a href="#Spring家族框架（掌握-2-3month）" class="headerlink" title="Spring家族框架（掌握,2-3month）"></a>Spring家族框架（掌握,2-3month）</h4><ul><li><strong>Spring</strong><ul><li>IoC</li><li>AOP</li></ul></li><li><strong>SpringMVC</strong></li><li><strong>Spring Boot</strong><ul><li>自动配置、开箱即用</li><li>整合Web</li><li>整合数据库（事务问题）</li><li>整合权限<ul><li>Shiro</li><li>Spring Security</li></ul></li><li>整合各种中间件<ul><li>Redis、 MQ、 RPC框架、NIO框架</li></ul></li></ul></li></ul><h4 id="服务器框架"><a href="#服务器框架" class="headerlink" title="服务器框架"></a>服务器框架</h4><ul><li>Web服务器<ul><li>Nginx（重要）</li></ul></li><li>应用服务器<ul><li>Tomcat</li><li>Jetty</li><li>Undertow（性能较好）</li></ul></li></ul><h4 id="中间件（应对高并发、大容量）"><a href="#中间件（应对高并发、大容量）" class="headerlink" title="中间件（应对高并发、大容量）"></a>中间件（应对高并发、大容量）</h4><ul><li>缓存<ul><li><strong>Redis</strong>（掌握，重要,2week）<ul><li>书籍：《Redis设计与实践》</li><li>5大基础数据类型</li><li>事务</li><li>管道</li><li>持久化</li><li>集群</li></ul></li></ul></li><li>消息队列（学一个即可）<ul><li>RocketMQ</li><li>RabbitMQ</li><li>Kafka（大数据）</li></ul></li><li>RPC框架<ul><li>Dubbo</li><li>gRPC</li><li>Thrift</li><li>Spring Cloud</li><li>Netty</li></ul></li></ul><h2 id="应用框架"><a href="#应用框架" class="headerlink" title="应用框架"></a>应用框架</h2><ul><li>数据库框架<ul><li><strong>ORM层框架</strong>（掌握）<ul><li>Mybatis</li><li>Hibernate</li><li>JPA</li></ul></li><li><strong>连接池</strong>（掌握）<ul><li>Druid</li><li>HikariCP</li><li>C3P0</li></ul></li><li>分库分表<ul><li>MyCAT</li><li>Sharding-JDBC</li><li>Sharding-Sphere</li></ul></li></ul></li><li>搜索引擎（了解）<ul><li>ElasticSearch</li><li>Solr</li></ul></li><li>分布式/微服务（了解,2-3week）<ul><li>服务发现/注册<ul><li>Eureka</li><li>Consul</li><li>Zookeeper（重要）</li><li>Nacos</li></ul></li><li>网关<ul><li>Zuul</li><li>Gateway</li></ul></li><li>服务调用（负载均衡）<ul><li>Ribbon</li><li>Feign</li></ul></li><li>熔断/降级<ul><li>Hystrix</li></ul></li><li>配置中心<ul><li>Config</li><li>Apollo</li><li>Nacos</li></ul></li><li>认证和鉴权（稍微重要些）<ul><li>Spring Security</li><li>OAuth2</li><li>SSO单点登录</li></ul></li><li>分布式事务<ul><li>JTA接口——Atomikos组件</li><li>2PC、3PC</li><li>XA模式</li><li>TCC模式——tcc-transaction、ByteTCC、EasyTransaction、SeaTa</li><li>SAGA模式——ServiceComb、Seata</li><li>LCN模式——tx-Icn</li></ul></li><li>任务调度<ul><li>Quartz</li><li>Elastic-Job</li></ul></li><li>链路追踪和监控<ul><li>Zipkin</li><li>Sleuth</li><li>Skywalking</li></ul></li><li>日志分析与监控——ELK<ul><li>ElasticSearch</li><li>Logstash</li><li>Kibana</li></ul></li><li>虚拟化/容器化<ul><li>容器化——Docker</li><li>容器编排技术——Kubernetes、Swarm</li></ul></li></ul></li></ul><h3 id="前端（了解）"><a href="#前端（了解）" class="headerlink" title="前端（了解）"></a>前端（了解）</h3><ul><li>基础套餐（大致了解，2-3天）<ul><li>三大件<ul><li>HTML</li><li>JavaScript</li><li>CSS</li></ul></li><li>基础库<ul><li>jQuery</li><li>Ajax</li></ul></li></ul></li><li>模板框架<ul><li>JSP/JSTL（已过时）</li><li>Thymeleaf</li><li>FreeMarker</li></ul></li><li>组件化框架<ul><li>Vue</li><li>React</li><li>Angular</li></ul></li></ul><h2 id="运维知识（配置）"><a href="#运维知识（配置）" class="headerlink" title="运维知识（配置）"></a>运维知识（配置）</h2><ul><li>Web服务器<ul><li>Nginx</li></ul></li><li>应用服务器<ul><li>Tomcat</li><li>Jetty</li><li>Undertow</li></ul></li><li>CDN加速</li><li>持续集成/持续部署<ul><li>Jenkins</li></ul></li><li>代码质量检查<ul><li>sonar</li></ul></li><li>日志收集和分析<ul><li>ELK</li></ul></li></ul><h2 id="成神之路"><a href="#成神之路" class="headerlink" title="成神之路"></a>成神之路</h2><ul><li>徒手撕源码</li><li>光脚造轮子</li><li>闭着眼睛深度调优</li><li>吊打面试官</li></ul><h2 id="平稳降落"><a href="#平稳降落" class="headerlink" title="平稳降落"></a>平稳降落</h2>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>后端</category>
      
      <category>学习路线</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>运用系统思维对热门计算机技术进行分析和介绍</title>
    <link href="/2021/12/06/%E8%BF%90%E7%94%A8%E7%B3%BB%E7%BB%9F%E6%80%9D%E7%BB%B4%E5%AF%B9%E7%83%AD%E9%97%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF%E8%BF%9B%E8%A1%8C%E5%88%86%E6%9E%90%E5%92%8C%E4%BB%8B%E7%BB%8D/"/>
    <url>/2021/12/06/%E8%BF%90%E7%94%A8%E7%B3%BB%E7%BB%9F%E6%80%9D%E7%BB%B4%E5%AF%B9%E7%83%AD%E9%97%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF%E8%BF%9B%E8%A1%8C%E5%88%86%E6%9E%90%E5%92%8C%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<p>近年来，电竞游戏人气日益火爆。从一年前火爆全球的“吃鸡”，到备受追捧的电竞游戏英雄联盟，不断吸引着年轻人的目光。</p><p>同时，高刷显示器和各种计算机设备开始不断升级。所谓磨刀不误砍柴工，有一个好的设备往往是游戏致胜的关键。从前，玩家们大多关注FPS的数值。而现在，另一项能影响玩家反应速度的参数——延迟，也开始被玩家注意起来。</p><p>为此，NVIDIA提供了一套用于在竞技游戏中优化和测量延迟的技术——NVIDIA Reflex。这是一项可以测量和降低竞技游戏延迟的软件技术，使得玩家能更迅速地击毙敌人。</p><p>硬件资源就那么多，虽然技术不断迭代升级，但是这个过程是及其漫长的。但是为了更好地提升体验，只能往“使用方式”的方向思考。</p><p>操作系统的发展过程中，不同的处理方式和算法，最终目的都是一个——更好地利用硬件资源，即提高硬件资源的利用率。</p><p>回到Reflex，什么是延迟呢？延迟是指网络延迟和系统延迟。顾名思义，网络延迟是“传输数据需要一定的时间”。系统延迟是鼠标和键盘按键后计算机也需要一定时间来反应。关于延迟，还有很多详细的分类：<br>外设延迟：输入设备处理机械输入并将这些输入事件发送到 PC 所需的时间<br>游戏延迟：CPU 处理对游戏世界的输入或更改并提交新帧供 GPU 渲染所需的时间<br>渲染延迟：从待渲染的帧排队列齐到 GPU 完全渲染帧之间的时间<br>PC 延迟：帧在 PC 上传输所需的时间。这包括游戏延迟和渲染延迟<br>显示延迟：GPU 完成帧渲染后，显示器呈现新图像所需的时间<br>系统延迟：涵盖整个端到端测量的时间 – 从外设延迟开始到显示延迟结束  </p><p>总所周知，游戏分辨率越高，图像质量越好，画面延迟就会越高，玩家的游戏体验越差。</p><p>玩家点击鼠标或者键盘之后，会产生IO输入，IO输入会随着操作系统的IO方式进入缓冲区中，随后CPU将会对该输入和游戏的当前画面进行分析，并且提交新的画面帧给显卡的GPU进行渲染。</p><p>但是很多时候，GPU的渲染跟不上CPU的速度。在操作系统里面，我们使用了cache来解决CPU和主存之间速度不匹配的问题。那么，渲染帧的过程该怎么办呢？没错，加一个“中介”即可。这个“中介”就是渲染队列。CPU把需要渲染的帧放在队列里面，GPU渲染完了再去取就行了。那么问题就出现在，渲染队列的帧积压着，那样就产生了延迟。</p><p>NVIDIA Reflex的核心就是解决这一步。</p><p>我们可以看到队列中已经充满了帧。CPU 处理帧的速度快于 GPU 渲染帧的速度，造成了这种作业积压，从而导致渲染延迟增加。当开发人员在游戏中集成Reflex SDK之后，他们就可以通过动态调整渲染工作提交给GPU的时间，直接控制CPU从渲染队列和管线的其他下游阶段获得的背压量来降低渲染延迟，来有效地延缓输入和游戏模拟的采样，以确保能够得到及时的处理。</p><p>然而，reflex“取消了”渲染队列，那么不是在拖CPU后腿了么？<br>想要GPU渲染快，可以降低帧数，Gpu速度提升了，压力就到了cpu这里。所以需要动态地去调整cpu和gpu的关系。而Reflex可以很好地控制cpu的速度，把它控制在一个“让gpu能毫无空隙的情况下处理作业”的速度，从而进一步降低延迟。<br>目前，这项技术获得了巨大的成功。那么这项技术和本课程所学的“操作系统”有什么联系呢？</p><ol><li>渲染队列的存在，和cache的存在原因比较相似。</li><li>这项技术离不开操作系统和硬件的支持，它完成的工作，是提高了cpu和gpu的利用率。reflex这项技术，是设计了一个更加好的“思路”和“算法”，来管理自己少得可怜而又十分珍贵的硬件“资源”。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>管理数据库对象</title>
    <link href="/2021/12/01/%E7%AE%A1%E7%90%86%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%B9%E8%B1%A1/"/>
    <url>/2021/12/01/%E7%AE%A1%E7%90%86%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<p>面向对象的数据库：使用范围很小  </p><p>具体应用：</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- 管理数据库对象</span><br><span class="hljs-comment">-- 创建地址对象类型</span><br><span class="hljs-keyword">create</span> type address_type <span class="hljs-keyword">as</span> object(<br>street varchar2(<span class="hljs-number">16</span>),<br>city varchar2(<span class="hljs-number">16</span>),<br>state <span class="hljs-type">char</span>(<span class="hljs-number">2</span>),<br>zip varchar2(<span class="hljs-number">6</span>)<br>);<br><br><span class="hljs-keyword">create</span> type person_type <span class="hljs-keyword">as</span> object(<br>id number,<br>first_name VARCHAR2(<span class="hljs-number">10</span>),<br>last_name VARCHAR2(<span class="hljs-number">10</span>),<br>dob <span class="hljs-type">date</span>,<br>phone varchar2(<span class="hljs-number">12</span>),<br>address address_type<br>);<br><br><span class="hljs-comment">-- 创建产品</span><br><span class="hljs-keyword">create</span> type product_type <span class="hljs-keyword">as</span> object(<br>id number,<br>name VARCHAR2(<span class="hljs-number">16</span>),<br>desception varchar2(<span class="hljs-number">22</span>),<br>price number(<span class="hljs-number">5</span>,<span class="hljs-number">2</span>),<br>days_valid number,<br><span class="hljs-keyword">member</span> <span class="hljs-keyword">FUNCTION</span> get_sell_by_date <span class="hljs-keyword">return</span> <span class="hljs-type">date</span><br>)<br><br><br><span class="hljs-keyword">create</span> type body product_type <span class="hljs-keyword">as</span> <span class="hljs-keyword">member</span> <span class="hljs-keyword">function</span> get_sell_by_date <span class="hljs-keyword">return</span> <span class="hljs-type">date</span> <span class="hljs-keyword">is</span><br>sell_by_date <span class="hljs-type">date</span>;<br><span class="hljs-keyword">BEGIN</span><br><span class="hljs-keyword">SELECT</span><br>days_valid<span class="hljs-operator">+</span>sysdate<br><span class="hljs-keyword">into</span><br>sell_by_date<br><span class="hljs-keyword">from</span> dual;<br><span class="hljs-keyword">return</span> sell_by_date;<br><span class="hljs-keyword">end</span>;<br><span class="hljs-keyword">end</span>;<br><br><br><span class="hljs-comment">-- 可以使用对象类型定义表中的列，这种列称为列对象</span><br><span class="hljs-comment">-- 列对象</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> products(<br>product product_type,<br>Quantity_in_stack number<br>)<br><br><span class="hljs-comment">-- 对象表</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> object_products <span class="hljs-keyword">of</span> product_type<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> object_customers <span class="hljs-keyword">of</span> person_type<br><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> object_products<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> object_customers<br><br><span class="hljs-comment">-- 对象表使用对象引用来表示对象表之间的关系，而不是使用外键</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> purchases(<br>id number <span class="hljs-keyword">primary</span> key,<br>customer <span class="hljs-keyword">ref</span> person_type <span class="hljs-keyword">scope</span> <span class="hljs-keyword">is</span> object_customers,<br>product <span class="hljs-keyword">ref</span> product_type <span class="hljs-keyword">scope</span> <span class="hljs-keyword">is</span> object_products<br>)<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> products <span class="hljs-keyword">values</span>(<br>product_type(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;香皂&#x27;</span>，<span class="hljs-string">&#x27;made in china&#x27;</span>,<span class="hljs-number">2.99</span>,<span class="hljs-number">5</span>),<span class="hljs-number">15</span><br>)<br><br><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> products<br><br><span class="hljs-comment">-- 向对象表中插入数据</span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> object_products <span class="hljs-keyword">VALUES</span>(<br><span class="hljs-number">2</span>,<span class="hljs-string">&#x27;sardines&#x27;</span>,<span class="hljs-string">&#x27;12box of sardines&#x27;</span>,<span class="hljs-number">2.99</span>,<span class="hljs-number">5</span><br>)<br><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> object_products;<br><br><br><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>oracle数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>oracle数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>管理概要文件</title>
    <link href="/2021/12/01/%E7%AE%A1%E7%90%86%E6%A6%82%E8%A6%81%E6%96%87%E4%BB%B6/"/>
    <url>/2021/12/01/%E7%AE%A1%E7%90%86%E6%A6%82%E8%A6%81%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>作用：限制数据库可以访问的资源，<br>概要文件利用各种参数和值来定义对口令资源、内核资源等各个方面的使用限额。<br>内容：资源限定的集合<br>意义：</p><ol><li>管理口令策略：限制口令的使用天数，使口令满足某种复杂程序等</li><li>比如某个用户不允许使用三个以上会话进行登录</li></ol><h1 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h1><p>查询方式：</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> dba_profiles<br></code></pre></div></td></tr></table></figure><h2 id="resource属性有两大类："><a href="#resource属性有两大类：" class="headerlink" title="resource属性有两大类："></a>resource属性有两大类：</h2><ol><li>密码的限制password</li><li>内核的限制kernel</li></ol><h2 id="profile属性有"><a href="#profile属性有" class="headerlink" title="profile属性有"></a>profile属性有</h2><ol><li>MONITORING_PROFILE</li><li>DEFAULT</li></ol><h2 id="limit属性表示是否被限制"><a href="#limit属性表示是否被限制" class="headerlink" title="limit属性表示是否被限制"></a>limit属性表示是否被限制</h2><p>比如FAILED_LOGIN_ATTEMPTS的“10”表示限制登录错误次数为10</p><h2 id="resource-name表示资源名"><a href="#resource-name表示资源名" class="headerlink" title="resource_name表示资源名"></a>resource_name表示资源名</h2><ol><li>CPU_PER_CALL：可以消耗的cpu时长</li><li>FAILED_LOGIN_ATTEMPTS：限制登录次数</li><li>……</li></ol>]]></content>
    
    
    <categories>
      
      <category>oracle数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>oracle数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>oracle物理备份和恢复数据库</title>
    <link href="/2021/11/28/oracle%E7%89%A9%E7%90%86%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2021/11/28/oracle%E7%89%A9%E7%90%86%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="oracle物理备份和恢复数据库"><a href="#oracle物理备份和恢复数据库" class="headerlink" title="oracle物理备份和恢复数据库"></a>oracle物理备份和恢复数据库</h1><p>oracle物理备份是把oracle数据库当中的文件备份到另外一个存储空间上，以备下次物理恢复。因此，物理备份和恢复的方式是一种比较快捷简便的保护数据库安全的策略。这就是所说的冷备份和热备份</p><h1 id="脱机备份"><a href="#脱机备份" class="headerlink" title="脱机备份"></a>脱机备份</h1><p>脱机备份叫冷备份。首先数据库管理员在关闭数据库服务的情况下，对数据库备份文件进行拷贝存储到另外一个存储空间上。然后要恢复的时候，把备份的文件重新拷贝到数据库对应的文件目录下，完成数据库恢复。</p><p>进行物理备份的文件有数据文件、日志文件、控制文件。具体位置可以通过数据字典：v_$datafile、v_$logfile、v_$controlfile查询</p><ol><li>v_$datafile存储的是数据文件在本地硬盘中存放的位置，是以.DBF结尾的文件。</li><li>v_$logfile存储的是日志文件的具体位置，保存的是.LOG文件</li><li>v_$controlfile存储的是.CTL结尾的文件</li></ol><p>查询语句：</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> t.name <span class="hljs-keyword">from</span> sys.v_$datafile t;<br></code></pre></div></td></tr></table></figure><h1 id="联机备份"><a href="#联机备份" class="headerlink" title="联机备份"></a>联机备份</h1><p>联机备份是热备份，是数据库开启归档模式下进行的备份。oracle数据库在安装的时候是不开启归档日志的。可以通过</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">archive <span class="hljs-built_in">log</span> list<br></code></pre></div></td></tr></table></figure><p>进行查看。</p><h2 id="设置数据库为归档模式"><a href="#设置数据库为归档模式" class="headerlink" title="设置数据库为归档模式"></a>设置数据库为归档模式</h2><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">--设置数据库的日志为归档模式</span><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">system</span> <span class="hljs-keyword">set</span> log_archive_start<span class="hljs-operator">=</span><span class="hljs-literal">true</span> <span class="hljs-keyword">scope</span><span class="hljs-operator">=</span>spfile<br><span class="hljs-comment">--关闭数据库</span><br>shutdown immediate；<br><span class="hljs-comment">--启动数据库实例但是不启动数据库</span><br>startup mount;<br><span class="hljs-comment">--设置当前数据库启用归档日志模式</span><br><span class="hljs-keyword">alter</span> database archivelog;<br><span class="hljs-comment">--启动数据库</span><br><span class="hljs-keyword">alter</span> database <span class="hljs-keyword">open</span>;<br></code></pre></div></td></tr></table></figure><h2 id="归档模式下备份表空间"><a href="#归档模式下备份表空间" class="headerlink" title="归档模式下备份表空间"></a>归档模式下备份表空间</h2><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">--1.开始备份表空间STUDENT</span><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span>space student <span class="hljs-keyword">begin</span> backup;<br><span class="hljs-comment">--2.找到数据文件，上面有命令可以查DBF文件，把它复制到另外一个地方去</span><br><span class="hljs-comment">--3.结束表空间备份</span><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span>space student <span class="hljs-keyword">end</span> backup;<br></code></pre></div></td></tr></table></figure><p>那么怎样恢复呢？</p><ol><li>关闭数据库服务器。然后把dbf文件删除。</li><li>删除后重新启动数据库，发现报错</li><li>恢复的时候，需要缺失的数据文件设置成脱机状态，并且删除。命令如下：<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> database datafile <span class="hljs-number">6</span> offline <span class="hljs-keyword">drop</span>;<br></code></pre></div></td></tr></table></figure>数据文件6是启动服务的时候报错找不到数据文件6</li><li>使用alter database open；启动数据库</li><li>吧备份好的数据文件复制到原来 位置</li><li>执行命令recover datafile 6；</li><li>恢复后设置文件为联机状态<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> database datafile <span class="hljs-number">6</span> online;<br></code></pre></div></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>oracle数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>oaracle数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>plsql</title>
    <link href="/2021/11/28/plsql/"/>
    <url>/2021/11/28/plsql/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>SQL语句是用来访问和操作关系型数据库的一种通用语言，不仅仅是在Oracle数据库可以使用，在其它关系型数据库也适用。但是这个SQL语言有一个弊端就是只能查询既得结果，不能做过程化的开发，因此，有时候SQL语言满足不了程序上复杂化的开发。所以，Oracle中的PL/SQL语言正是为了解决这一问题。<br>特点：</p><ol><li><p>支持SQL语句命令和操作。</p></li><li><p>支持SQL中的数据类型，还扩展了一些自己特有的类型，如：type类型。</p></li><li><p>支持SQL中的内置函数和运算符。</p></li><li><p>PL/SQL支持事物，对写好的PL/SQL程序（过程、函数、包）可以进行权限的控制。</p></li><li><p>PL/SQL编写的数据库脚本是保留在Oracle服务器中的。</p></li></ol><h1 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h1><p>PL/SQL 是一种块结构的语言，它将一组语句放在一个块中，一次性发送给服务器，PL/SQL 块发送给服务器后，先被编译然后执行， PL/SQL引擎分析收到 PL/SQL 语句块中的内容， 把其中的过程控制语句由 PL/SQL 引擎自身去执行，把 PL/SQL 块中的 SQL 语句交给服务器的 SQL 语句执行器执行</p><h1 id="块"><a href="#块" class="headerlink" title="块"></a>块</h1><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">[<span class="hljs-keyword">DECLARE</span>]<br>声明语句...<br><span class="hljs-keyword">BEGIN</span><br>执行语句...<br>[EXCEPTION]<br>异常处理语句...<br><span class="hljs-keyword">END</span><br></code></pre></div></td></tr></table></figure><ol><li><p>声明部分是可选部分，由DECLARE开始，声明执行部分所需的变量或者常量。假如，没有用到变量或者常量可以省略。</p></li><li><p>执行部分是由BEGIN开始，END结束。是PL/SQL块语句的核心部分，所有的可执行的PL/SQL语句和操作变量都放在该部分。是必选的部分，不能省略。</p></li><li><p>异常部分是由EXCEPTION开始。主要处理执行部分过程中的执行语句或者赋值操作出现错误时，就会进入该部分。是PL/SQL程序的异常处理部分，不是必须的。</p></li></ol><p>执行plsql之前，需要set serveroutput on 命令是打开COMMAND命令窗口中的输出流。以便查看输出结果。</p><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">declare</span><br>xsjbxx varchar2(<span class="hljs-number">50</span>);<br><span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">select</span> <span class="hljs-string">&#x27;姓名:&#x27;</span> <span class="hljs-operator">||</span>t.stuname <span class="hljs-operator">||</span> <span class="hljs-string">&#x27; 学号:&#x27;</span> <span class="hljs-operator">||</span> t.stuid <span class="hljs-operator">||</span> <span class="hljs-string">&#x27; 年龄：&#x27;</span> <span class="hljs-operator">||</span> t.age<br>   <span class="hljs-keyword">into</span> xsjbxx<br>    <span class="hljs-keyword">from</span> stuinfo t<br>   <span class="hljs-keyword">where</span> t.stuname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;张三&#x27;</span>;<br>  dbms_output.put_line(xsjbxx);<br>exception<br>  <span class="hljs-keyword">when</span> no_data_found  <span class="hljs-keyword">then</span><br>     dbms_output.put_line(<span class="hljs-string">&#x27;该学生在学生信息表中找不到&#x27;</span>);<br><span class="hljs-keyword">end</span>;<br></code></pre></div></td></tr></table></figure><p>注意：</p><ol><li>select … into是PL/SQL程序中对SQL查询语句给变量赋值方法。是PL/SQL程序特有的赋值语句，该赋值语句只能要求SQL语句查询出来的值只有一个，假如多个或者一个都没有回抛出异常。</li><li>DBMS_OUTPUT.PUT_LINE是Oracle系统自带的包中的过程，用来做输出流打印，经常可以用来开发PL/SQL程序时做测试用。</li></ol>]]></content>
    
    
    <categories>
      
      <category>oracle数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>oracle数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sql</title>
    <link href="/2021/11/28/sql/"/>
    <url>/2021/11/28/sql/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在 Oracle 开发中，客户端把 SQL 语句发送给服务器，服务器对 SQL 语句进行编译、执行，把执行的结果返回给客户端。常用的SQL语句大致可以分为五类：</p><ol><li><p>数据定义语言（DDL），包括 CREATE（创建）命令、 ALTER（修改）命令、 DROP（删除）命令等。</p></li><li><p>数据操纵语言（DML），包括 INSERT（插入）命令、 UPDATE（更新）命令、 DELETE（删除）命令、 SELECT … FOR UPDATE（查询）等。</p></li><li><p>数据查询语言（DQL），包括基本查询语句、 Order By 子句、 Group By 子句等。</p></li><li><p>事务控制语言（TCL），包括 COMMIT（提交）命令、 SAVEPOINT（保存点）命令、ROLLBACK（回滚）命令。     </p></li><li><p>数据控制语言（DCL）， GRANT（授权）命令、 REVOKE（撤销）命令。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>oracle数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>oracle数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>oracle数据库管理</title>
    <link href="/2021/11/28/oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/"/>
    <url>/2021/11/28/oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="oracle服务"><a href="#oracle服务" class="headerlink" title="oracle服务"></a>oracle服务</h1><h2 id="oracleserviceoracl"><a href="#oracleserviceoracl" class="headerlink" title="oracleserviceoracl"></a>oracleserviceoracl</h2><p>该服务是oracle数据库的基础，只有启动该服务才能正常使用oracle数据库</p><h2 id="oracleoradb11g-home1TNSlistener"><a href="#oracleoradb11g-home1TNSlistener" class="headerlink" title="oracleoradb11g_home1TNSlistener"></a>oracleoradb11g_home1TNSlistener</h2><p>该服务为oracle数据库提供监听程序服务，只有启动该服务，本地的客户端程序才能通过监听程序连接数据库，和数据库进行交互。</p><h1 id="oracle数据库的启动和关闭"><a href="#oracle数据库的启动和关闭" class="headerlink" title="oracle数据库的启动和关闭"></a>oracle数据库的启动和关闭</h1><ol><li>启动：oracleservice服务启动之后，就可以操作数据库了</li><li>关闭：shutdown immediate</li><li>重新启动oracle数据库和实例：startup open</li></ol><h1 id="oracle用户"><a href="#oracle用户" class="headerlink" title="oracle用户"></a>oracle用户</h1><p>oracle数据库内有许多表。其中有某一堆表属于用户A。数据库中的用户，用于组织和管理数据库对象的。通常一个应用软件的数据库对象存放在一个数据库用户下。使用数据库用户连接数据库后，可以对这些数据库对象进行操作。</p><h2 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h2><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- Create the user </span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">user</span> student<span class="hljs-comment">--用户名</span><br>  identified <span class="hljs-keyword">by</span> &quot;123456&quot;<span class="hljs-comment">--密码</span><br>  <span class="hljs-keyword">default</span> tablespace USERS<span class="hljs-comment">--表空间名</span><br>  temporary tablespace temp <span class="hljs-comment">--临时表空间名</span><br>  profile <span class="hljs-keyword">DEFAULT</span>    <span class="hljs-comment">--数据文件（默认数据文件）</span><br>  account unlock; <span class="hljs-comment">-- 账户是否解锁（lock:锁定、unlock解锁）</span><br><br></code></pre></div></td></tr></table></figure><p>但是这个用户还不能登录数据库，因为它还没有权限，至少需要一create session系统权限才能登录数据库</p><h1 id="oracle权限"><a href="#oracle权限" class="headerlink" title="oracle权限"></a>oracle权限</h1><p>权限必须是由系统管理员sys分配的<br>oracle数据库用户权限分为：系统权限和对象权限两种</p><ol><li>系统权限：比如create session可以和数据库进行连接，create table、create view等可以创建表格或者视图</li><li>对象权限：比如对表中的数据进行增删改查操作，拥有数据库对象权限的用户可以对所拥有的的权限的表格进行操作。<h2 id="具体权限："><a href="#具体权限：" class="headerlink" title="具体权限："></a>具体权限：</h2></li><li>select</li><li>insert</li><li>update</li><li>delete</li><li>references</li><li>alter</li><li>index</li><li>execute</li><li>read</li></ol><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><p>角色就是一组权限的集合。用户可以拥有某种角色或者多个角色。<br>常用的数据库角色有</p><ol><li>connect角色，是oracle用户的基本角色，代表用户可以和oracle数据库连接，建立session</li><li>resource角色，是开发过程中常用的角色。RESOURCE给用户提供了可以创建自己的对象，包括：表、视图、序列、过程、触发器、索引、包、类型等。</li><li>DBA角色：DBA角色是管理数据库管理员该有的角色。它拥护系统了所有权限，和给其他用户授权的权限。SYSTEM用户就具有DBA权限。</li></ol><p>授权和取消用户权限：</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">--GRANT 对象权限 on 对象 TO 用户    </span><br><span class="hljs-keyword">grant</span> <span class="hljs-keyword">select</span>, <span class="hljs-keyword">insert</span>, update, <span class="hljs-keyword">delete</span> <span class="hljs-keyword">on</span> JSQUSER <span class="hljs-keyword">to</span> STUDENT;<br><br><span class="hljs-comment">--GRANT 系统权限 to 用户</span><br><span class="hljs-keyword">grant</span> <span class="hljs-keyword">select</span> <span class="hljs-keyword">any</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">to</span> STUDENT;<br><br><span class="hljs-comment">--GRANT 角色 TO 用户</span><br><span class="hljs-keyword">grant</span> <span class="hljs-keyword">connect</span> <span class="hljs-keyword">to</span> STUDENT;<span class="hljs-comment">--授权connect角色</span><br><span class="hljs-keyword">grant</span> resource <span class="hljs-keyword">to</span> STUDENT;<span class="hljs-comment">--授予resource角色</span><br><br><span class="hljs-comment">-- Revoke 对象权限 on 对象 from 用户 </span><br><span class="hljs-keyword">revoke</span> <span class="hljs-keyword">select</span>, <span class="hljs-keyword">insert</span>, update, <span class="hljs-keyword">delete</span> <span class="hljs-keyword">on</span> JSQUSER <span class="hljs-keyword">from</span> STUDENT;<br><br><span class="hljs-comment">-- Revoke 系统权限  from 用户</span><br><span class="hljs-keyword">revoke</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">ANY</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">from</span> STUDENT;<br><br><span class="hljs-comment">-- Revoke 角色（role） from 用户</span><br><span class="hljs-keyword">revoke</span> RESOURCE <span class="hljs-keyword">from</span> STUDENT;<br></code></pre></div></td></tr></table></figure><h3 id="预定义角色"><a href="#预定义角色" class="headerlink" title="预定义角色"></a>预定义角色</h3><p>数据库安装的时候，oracle会运行几个脚本，自动创建一些对象，比如数据字典视图，并且创建一些角色，然后给这些对象分配角色<br>传统常用的角色：</p><ol><li>CONNECT</li></ol><p>新创建的角色是没有任何权限的，需要手动分配系统权限和对象权限给它。系统选线和对象权限需要分开授权</p><h1 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h1><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">--修改用户信息</span><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">user</span> STUDENT<br>  identified <span class="hljs-keyword">by</span> <span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span>  <span class="hljs-comment">--修改密码</span><br>  account lock;<span class="hljs-comment">--修改用户处于锁定状态或者解锁状态 （LOCK|UNLOCK ）</span><br></code></pre></div></td></tr></table></figure><h1 id="管理数据文件"><a href="#管理数据文件" class="headerlink" title="管理数据文件"></a>管理数据文件</h1><p>顾名思义，数据库中的数据都是要存储在磁盘的，以磁盘或者硬盘数据文件形式保存<br><strong>数据文件只属于一个表空间，生成的时候必须指定表空间，否则是垃圾文件。</strong></p><pre><code class=" mermaid">graph TD;数据库--&gt;表空间;表空间--&gt;数据文件1;表空间--&gt;数据文件n;表空间--&gt;数据文件2;</code></pre><h2 id="作用？"><a href="#作用？" class="headerlink" title="作用？"></a>作用？</h2><ol><li>遵守限制，确定数据文件的大小和数量</li><li>提高效率，合理放置文件，例如放在不同磁盘减少io冲突</li><li>消除竞争，将数据文件和日志文件分散放置</li></ol><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">#为表空间添加数据文件<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span>SPACE MYTS01 <span class="hljs-keyword">ADD</span> DATAFILE <span class="hljs-string">&#x27;D:\ORADATA\myts01_03.dbf&#x27;</span>SIZE <span class="hljs-number">6</span>M;<br><br>#为表空间添加临时数据文件<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span>SPACE MYTMPTS01 <span class="hljs-keyword">ADD</span> TEMPFILE <span class="hljs-string">&#x27;D:\ORADATA\mytmpts01_3.dbf &#x27;</span>SIZE <span class="hljs-number">4</span>M;<br><br>#在创建表空间MYTS02时将数据文件myts02_1.dbf设置为自<br>动增长方式。<br><span class="hljs-keyword">CREATE</span> SMALLFILE TABLESPACE MYTS02<br>DATAFILE <span class="hljs-string">&#x27;D:\ORADATA\myts02_1.dbf&#x27;</span> SIZE <span class="hljs-number">2</span>M<br>AUTOEXTEND <span class="hljs-keyword">ON</span><br><br>#在表空间myts02创建之后再添加一个新的自动增长方式的数据文件。<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span>SPACE myts02 <span class="hljs-keyword">ADD</span> DATAFILE <span class="hljs-string">&#x27;D:\ORADATA\mytts02_2.dbf &#x27;</span>SIZE <span class="hljs-number">4</span>M<br>AUTOEXTEND <span class="hljs-keyword">ON</span><br>NEXT <span class="hljs-number">4</span>K<br>MAXSIZE <span class="hljs-number">40</span>M;<br><br>#使用下面语句将数据文件myts01_03.dbf设置为自动增长方式<br><span class="hljs-keyword">ALTER</span> DATABASE<br>DATAFILE <span class="hljs-string">&#x27;D:\ORADATA\myts01_03.dbf‘</span><br><span class="hljs-string">AUTOEXTEND ON</span><br><span class="hljs-string">NEXT 2M</span><br><span class="hljs-string">MAXSIZE 20M;</span><br><span class="hljs-string"></span><br><span class="hljs-string">#关闭自动增长</span><br><span class="hljs-string">ALTER DATABASE DATAFILE &#x27;</span>D:\ORADATA\myts01_03.dbf<span class="hljs-string">&#x27; AUTOEXTEND OFF;</span><br><span class="hljs-string"></span><br><span class="hljs-string">#修改数据文件大小</span><br><span class="hljs-string">ALTER DATABASE DATAFILE &#x27;</span>D:\ORADATA\myts01_03.dbf<span class="hljs-string">&#x27;</span><br><span class="hljs-string">RESIZE 8M;</span><br><span class="hljs-string"></span><br><span class="hljs-string">#修改可用性</span><br><span class="hljs-string">ALTER DATABASE DATAFILE &#x27;</span>D:\ORADATA\mytts02_2.dbf‘ online;<br><br></code></pre></div></td></tr></table></figure><h1 id="管理重做日志文件"><a href="#管理重做日志文件" class="headerlink" title="管理重做日志文件"></a>管理重做日志文件</h1><p>重做日志文件主要以重做记录的形式记录、保存对数据库所做的修改（事务）。<br>如果对一个表的数据进行了修改，并完成了事务的提交，这是数据文件中只保持<br>修改后的数据，但重做日志文件中要记录两类数据：修改前与修改后的数据</p><h2 id="切换日志文件"><a href="#切换日志文件" class="headerlink" title="切换日志文件"></a>切换日志文件</h2><p>日志切换：当LGWR停止向某个重做日志文件组写入而开始向另一<br>个联机重做日志文件组写入的那一刻</p><ol><li>通常发生在当前重做日志文件已经完全填满，而且必须继续填写下一个联机重做日志文件的时候。然而可以用基于时间的方式指定日志切换发生的时刻</li><li>强行日志切换：是使当前活动组变成非活动的，以便对该组实施重做日志文件的维护操作。必须拥有ALTER SYSTEM 权限。如果有这种权限，使用带SWITH LOGFILE字句的ALTER SYSTEM语句就可以强制实施日志切换，如：<strong>ALTER SYSTEM SWITCH LOGFILE；</strong></li></ol>]]></content>
    
    
    <categories>
      
      <category>oracle数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>oracle数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>白盒测试</title>
    <link href="/2021/11/27/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95/"/>
    <url>/2021/11/27/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="白盒测试和黑盒测试的区别"><a href="#白盒测试和黑盒测试的区别" class="headerlink" title="白盒测试和黑盒测试的区别"></a>白盒测试和黑盒测试的区别</h2><ol><li>黑盒测试：基于软件需求</li><li>白盒测试：基于程序内部设计和程序实现</li></ol><p>黑盒测试主要用于发现以下情况：</p><ol><li>在接口上行是否能正确接收输入数据，能否产生正确的输出信息。</li><li>访问外部数据库是否有错</li><li>性能上是否满足需求</li><li>界面上是否有错误，是否不美观</li><li>程序初始化和终止方面的问题</li></ol><p>白盒测试主要用于</p><ol><li>分析内部实现</li><li>识别被测软件的执行路径</li><li>选择输入、执行的被测路径，并且确定预期的测试结果</li><li>执行测试</li><li>比较实际输出和预期输出的异同</li><li>做出被测软件的功能正确性判断</li></ol><p>白盒测试的优势</p><ol><li>针对性强,便于快速定位缺陷</li><li>函数级别开始测试工作，缺陷修复的成本低</li><li>测试效率高，通过不同的白盒覆盖指标有助于衡量对被测对象的测试覆盖程度</li><li>有助于代码的优化和缺陷的预防</li></ol><p>白盒测试的局限性</p><ol><li>对测试人员的技术要求高</li><li>成本高，准备时间长</li></ol><h2 id="白盒测试的内容"><a href="#白盒测试的内容" class="headerlink" title="白盒测试的内容"></a>白盒测试的内容</h2><ol><li>测试程序内部的变量状态、逻辑结构、运行路径等</li><li>检验程序中每条通路是否能按照预定要求正确工作</li><li>检查程序内部动作或者运行是否符合设计规格要求，所有内部成分是否按照规定正常进行。</li></ol><h2 id="白盒测试的方法"><a href="#白盒测试的方法" class="headerlink" title="白盒测试的方法"></a>白盒测试的方法</h2><p>静态测试、对判定的屙屎、对路径的测试、对循环的测试、对变量的测试。其中静态测试是指<strong>代码测试、界面测试、文档测试</strong>。与之相反的动态测试是指人工或者利用工具运行程序进行检查，分析程序的执行状态和程序的外部表现。</p><h1 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h1><h2 id="适用阶段"><a href="#适用阶段" class="headerlink" title="适用阶段"></a>适用阶段</h2><h3 id="当被测对象是函数的时候"><a href="#当被测对象是函数的时候" class="headerlink" title="当被测对象是函数的时候"></a>当被测对象是函数的时候</h3><h3 id="当被测对象是功能的时候"><a href="#当被测对象是功能的时候" class="headerlink" title="当被测对象是功能的时候"></a>当被测对象是功能的时候</h3><h2 id="静态白盒测试"><a href="#静态白盒测试" class="headerlink" title="静态白盒测试"></a>静态白盒测试</h2><h3 id="代码检查的方法"><a href="#代码检查的方法" class="headerlink" title="代码检查的方法"></a>代码检查的方法</h3><h4 id="审查"><a href="#审查" class="headerlink" title="审查"></a>审查</h4><p>审查是软件行业的最佳实践。在代码审查的过程中一个重要部分是使用一个核对表检查程序中常见的错误。核对表类似于，需要检查的表，比如C++程序，核对表中应该有的检查项有include、调用、名字、字符串、指针、{}对……等等。</p><h4 id="团队评审"><a href="#团队评审" class="headerlink" title="团队评审"></a>团队评审</h4><h4 id="走查"><a href="#走查" class="headerlink" title="走查"></a>走查</h4><p>采用讲解、讨论和模拟运行的方式进行查找错误的活动。由本模块的开发者进行讲解、回答问题并记录。由测试组成员为测试程序准备一批有代表性的测试用例，交给走查小组。走查小组开会，集体扮演计算机角色，让测试用例沿着程序的逻辑运行一遍，随时记录程序的踪迹，公分析讨论使用。</p><h4 id="结对编程"><a href="#结对编程" class="headerlink" title="结对编程"></a>结对编程</h4><h4 id="同行桌查"><a href="#同行桌查" class="headerlink" title="同行桌查"></a>同行桌查</h4><h4 id="轮查"><a href="#轮查" class="headerlink" title="轮查"></a>轮查</h4><h4 id="特别检查"><a href="#特别检查" class="headerlink" title="特别检查"></a>特别检查</h4><h2 id="对判定的测试"><a href="#对判定的测试" class="headerlink" title="对判定的测试"></a>对判定的测试</h2><p>判定是重要的程序结构之一。判定结点的出现，导致程序执行出现分支，形成复杂多变的路径。考察代码的时候需要对判定进行重点测试。</p><h3 id="覆盖强度"><a href="#覆盖强度" class="headerlink" title="覆盖强度"></a>覆盖强度</h3><p>覆盖强度从弱到强：</p><ol><li>语句覆盖，使得程序中每个语句至少被执行一次</li><li>判定覆盖，使得程序中每个判定至少为真和假各一次。</li><li>条件覆盖，使得判定中每个条件获得各种可能的结果</li><li>判定-条件覆盖，满足2、3的测试用例</li><li>条件组合覆盖，对于每个判定结点，其简单判定条件的所有取值组合情况至少出现一次。对于短路表达式，条件组合覆盖不用覆盖后面短路的表达式。</li><li>修正的判定条件覆盖，</li></ol><p>注意：</p><ol><li>语句覆盖可以保证程序中每条语句都得到执行。但是发现不了判定中逻辑运算的错误。</li><li>判定覆盖无法找出判定条件内部错误</li><li>如果一组测试用例满足条件覆盖，但是它不一定满足判定覆盖</li></ol><p>修正的判定/条件覆盖</p><ol><li>程序中每个入口和出口都至少调用一次</li><li>判定/条件覆盖</li><li><strong>程序中一个判定的每个条件呈现出独立地影响该判定结果。</strong></li></ol><h2 id="对路径的测试"><a href="#对路径的测试" class="headerlink" title="对路径的测试"></a>对路径的测试</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>把全路径集合看做一个向量空间，并将从全路径抽取的一组线性无关的独立路径看做一组向量基。</p><h2 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h2><ol><li>根据程序源代码生成程序<strong>流图</strong></li><li>计算程序图的环复杂度，确定独立路径集合的大小</li><li>抽取独立路径集合，独立路径的数量等于环复杂度。基本路径选择，先选短的，如果判定结点两边一样长，就选左边的。</li><li>注意剔除不可行路径，必要时候补充其他重要路径。该过程使用路径分析，确定每个路径是否可行（检查判定结点的T或者F）</li><li>根据得到的路径集合设计测试用例，针对每一条路径设计相应的测试用例</li></ol><p>补充路径的基本原则</p><ol><li>补充执行概率较高的路径（计算每个判定下的结点的概率）</li><li>补充可能包含缺陷的路径（比如边界）</li><li>补充复杂度较高的路径</li></ol><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>独立路径测试的理论基础保证了测试的完备性和无冗余性</p><h2 id="对变量的测试"><a href="#对变量的测试" class="headerlink" title="对变量的测试"></a>对变量的测试</h2><ol><li>是否引用未定义的变量</li><li>是否定义变量未使用</li><li>是否多次定义变量</li></ol>]]></content>
    
    
    <categories>
      
      <category>软件测试</category>
      
      <category>白盒测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>黑盒测试</title>
    <link href="/2021/11/26/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/"/>
    <url>/2021/11/26/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>黑盒存世仅需要知道被测对象的输入和预期输出，不需要了解实现的细节。</p><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ol><li>黑盒测试方法对测试人员的技术要求相对较低</li><li>黑盒测试不需要了解程序实现的细节。测试团队和开发团队可以并行完成各自的任务<h2 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h2>测试结果的覆盖度不容易度量，测试的潜在风险高<h2 id="适用对象"><a href="#适用对象" class="headerlink" title="适用对象"></a>适用对象</h2><h3 id="当被测对象是函数的时候"><a href="#当被测对象是函数的时候" class="headerlink" title="当被测对象是函数的时候"></a>当被测对象是函数的时候</h3></li><li>完成对函数功能的测试</li><li>无需查看函数代码，只需要了解函数接口和返回值</li><li>对应单元测试阶段<h3 id="当对象为功能的时候"><a href="#当对象为功能的时候" class="headerlink" title="当对象为功能的时候"></a>当对象为功能的时候</h3></li><li>完成对整个软件系统功能的易用性等测试</li><li>无需看各功能点如何变成实现，只需要了解SRS中关于输入输出的规定</li><li>对应系统测试，所有用户共同参与的验收测试阶段<h2 id="测试方法的评价"><a href="#测试方法的评价" class="headerlink" title="测试方法的评价"></a>测试方法的评价</h2></li><li>测试用例对被测对象的覆盖率</li><li>测试用例的冗余</li><li>测试用例的数量</li><li>测试用例对缺陷的定位能力</li><li>测试用例的设计复杂度</li></ol><p>黑盒测试包括有效数据和无效数据，所以在测试的过程中不能仅仅关注有效测试。比如“计算两个1~100的整数的和”的程序中，两个输入框的100*100种数据组合仅仅是有效数据集。</p><h1 id="边界值测试"><a href="#边界值测试" class="headerlink" title="边界值测试"></a>边界值测试</h1><p>大量缺陷发生在输入或者输出范围的边界上</p><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>边界点就是可能导致被测系统内部处理机制发生变化的点<br>邻域就是某个边界点两边的值</p><h2 id="边界值测试数据的选择"><a href="#边界值测试数据的选择" class="headerlink" title="边界值测试数据的选择"></a>边界值测试数据的选择</h2><ol><li>穷举法</li><li>典型值法</li></ol><p>边界组合方式的选择</p><ol><li>强边界法——覆盖所有输入条件的所有边界组合</li><li>弱边界法——基于单缺陷假设，有且只有一个输入条件的取值为边界领域内的测试数据。大大降低测试用例数量</li><li>全边界法<br>强边界+弱边界</li></ol><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>边界值测试一般作为等价类测试的补充。同时基于<strong>两个</strong>重要假设：独立性假设和单缺陷假设。</p><h1 id="等价类测试"><a href="#等价类测试" class="headerlink" title="等价类测试"></a>等价类测试</h1><p>等价类测试方法通过划分的方式将数据分片，从每个分片中抽典型数据进行测试。</p><h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><ol><li>分而不交</li><li>合而不变</li><li>类内等价</li></ol><p>相信字面意思很好理解。比如“计算两个1~100的整数的和”的程序中，可以把输入分成三个等价类（只考虑输入数据的范围的情况下）——</p><ol><li>输入正确的数据。</li><li>其中一个数为负数</li><li>其中一个数大于100</li></ol><p>如果在这个程序中，考虑更多的无效输入，那么还会有：<br>4. 空格<br>5. 小数<br>6. 字母</p><p>但是，一般情况下，针对无效输入的测试并非测试重点。</p><h2 id="等价类测试的难点"><a href="#等价类测试的难点" class="headerlink" title="等价类测试的难点"></a>等价类测试的难点</h2><ol><li>选择被测对象</li><li>等价类的划分</li><li>测试用例的设计</li></ol><h2 id="输入域的确定"><a href="#输入域的确定" class="headerlink" title="输入域的确定"></a>输入域的确定</h2><h3 id="整体输入域"><a href="#整体输入域" class="headerlink" title="整体输入域"></a>整体输入域</h3><p>由多个输入条件共同构成的具有一定实际意义的输入域</p><h3 id="个体输入域"><a href="#个体输入域" class="headerlink" title="个体输入域"></a>个体输入域</h3><p>将整体输入域拆分成由各个输入条件分别构成的个体输入域进行等价划分</p><h2 id="等价类的分类"><a href="#等价类的分类" class="headerlink" title="等价类的分类"></a>等价类的分类</h2><ol><li>有效等价类——检查软件正常工作的能力</li><li>无效等价类——检查软件的容错能力<h2 id="等价类的划分"><a href="#等价类的划分" class="headerlink" title="等价类的划分"></a>等价类的划分</h2><h3 id="按照区间划分"><a href="#按照区间划分" class="headerlink" title="按照区间划分"></a>按照区间划分</h3>如果输入确定了取值范围，或者值的个数，就可以确定一个有效等价类和两个无效等价类。两个无效等价类分别是范围的左右两边<h3 id="按照数值划分"><a href="#按照数值划分" class="headerlink" title="按照数值划分"></a>按照数值划分</h3>如果输入条件规定了输入值的集合，那么可以确立一个有效等价类和一个无效等价类。因为输入条件只有“集合内”和“集合外”之分。<h3 id="按照限制条件划分"><a href="#按照限制条件划分" class="headerlink" title="按照限制条件划分"></a>按照限制条件划分</h3>如果输入条件是一个布尔值，那么可以确定一个有效等价类和一个无效等价类<h3 id="按照数值集合划分"><a href="#按照数值集合划分" class="headerlink" title="按照数值集合划分"></a>按照数值集合划分</h3>如果输入条件是一个逻辑量，即规定了一组输入数据的数值，而且程序要对每一个输入值进行处理，则可以为每一个输入值确立一个有效等价类，而对这组数值之外的所有值确定一个无效等价类</li></ol><h2 id="针对有效等价类的测试用例设计"><a href="#针对有效等价类的测试用例设计" class="headerlink" title="针对有效等价类的测试用例设计"></a>针对有效等价类的测试用例设计</h2><h3 id="强组合方式"><a href="#强组合方式" class="headerlink" title="强组合方式"></a>强组合方式</h3><p>最终得到的测试用例完全覆盖所有输入条件的有效等价类组合，强组合方式的测试用例集合是唯一的。</p><h3 id="弱组合方式"><a href="#弱组合方式" class="headerlink" title="弱组合方式"></a>弱组合方式</h3><p>测试用例仅需完全覆盖所有的输入条件的有效等价类，得到的测试用例集合并不是唯一的，不同的测试集合效果可能不一样。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>如果有两个输入条件，X1有三个有效等价类，X2有四个有效等价类，根据强/弱覆盖原则，二者的测试用例集合至少各有多少个？<br>强：12个<br>弱：4个</p><h2 id="针对无效等价类的测试用例设计"><a href="#针对无效等价类的测试用例设计" class="headerlink" title="针对无效等价类的测试用例设计"></a>针对无效等价类的测试用例设计</h2><h3 id="单缺陷假设"><a href="#单缺陷假设" class="headerlink" title="单缺陷假设"></a>单缺陷假设</h3><p>一个测试用例仅仅覆盖一个输入条件的某一个无效等价类，每个测试用例均不能同时覆盖多个无效等价类。</p><h2 id="输入域等价类的测试流程"><a href="#输入域等价类的测试流程" class="headerlink" title="输入域等价类的测试流程"></a>输入域等价类的测试流程</h2><p>确定有几个输入条件-&gt;划分每个输入条件的等价类-&gt;选择适合的覆盖标准-&gt;设计测试用例</p><h1 id="基于决策表的测试"><a href="#基于决策表的测试" class="headerlink" title="基于决策表的测试"></a>基于决策表的测试</h1><p>基于决策表的测试通过对决策表化简，消除测试用例的冗余，缩减测试用例的规模，同时保持等价类测试的效果。注意，是<strong>基于等价类测试的结果！</strong></p><h2 id="化简的前提条件"><a href="#化简的前提条件" class="headerlink" title="化简的前提条件"></a>化简的前提条件</h2><ol><li>输出相同</li><li>输入相似</li></ol><h1 id="基于场景的测试"><a href="#基于场景的测试" class="headerlink" title="基于场景的测试"></a>基于场景的测试</h1><p>基于场景的测试方法是以事件流为核心，基于这些时间触发控制业务流程，形成多个不同的场景。最终基于场景设计测试用例</p><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>用例场景用来描述流经用例的路径。从开始到结束遍历这条路径上的所有基本流和备选流</p><h3 id="基本流"><a href="#基本流" class="headerlink" title="基本流"></a>基本流</h3><p>从系统的某个初始状态开始，经过一系列的状态变化后到达终止状态过程中最重要的业务流程</p><h3 id="备选流"><a href="#备选流" class="headerlink" title="备选流"></a>备选流</h3><p>以基本流为基础，在经过基本流每个判定结点出满足不同的触发条件，导致其他的事件流。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>对于业务清晰的系统，可以利用场景发贯穿整个测试案例过程</li><li>首先进行等价类划分，包括输入条件和输出条件的等价划分，将无限测试变成有限测试，从而减少工作量和提高测试效率</li><li>在任何时候都要使用边界值分析方法。</li><li>若被测对象输入条件之间相互依赖，则基于有效域的等价划分使用决策表测试（如第二日问题）</li><li>度已于参数配置类的软件系统，当测试对象完全不了解的时候采用正交表的测试方法</li></ol>]]></content>
    
    
    <categories>
      
      <category>软件测试</category>
      
      <category>黑盒测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SSM与MVC</title>
    <link href="/2021/11/18/SSM%E4%B8%8EMVC/"/>
    <url>/2021/11/18/SSM%E4%B8%8EMVC/</url>
    
    <content type="html"><![CDATA[<h1 id="SSM和MVC是什么"><a href="#SSM和MVC是什么" class="headerlink" title="SSM和MVC是什么"></a>SSM和MVC是什么</h1><p>SSM是指spring+springMVC+mybatis集成的框架；MVC是指model+view+controller</p><h1 id="各层的作用"><a href="#各层的作用" class="headerlink" title="各层的作用"></a>各层的作用</h1><h2 id="model（entity）层"><a href="#model（entity）层" class="headerlink" title="model（entity）层"></a>model（entity）层</h2><p>实体类，属性和数据表的属性保持一致</p><h2 id="service层"><a href="#service层" class="headerlink" title="service层"></a>service层</h2><p>存放业务逻辑，也是关于数据库的一些操作。但是并不是直接面对数据库，它有接口和接口的实现方法。在接口实现方法中，需要使用mapper（dao）层。这里的mapper和dao层的区别在下文有描述。mapper层是直接和数据库打交道的。它也是一个接口，只有方法和名字。<br>在实际开发中，service层提供我们实际使用的方法。当然，service之间可以互相调用</p><h2 id="mapper（dao-层"><a href="#mapper（dao-层" class="headerlink" title="mapper（dao)层"></a>mapper（dao)层</h2><p>使用mybatis逆向工程生成的mapper层，实际上就是dao层。对数据库进行持久化操作。（数据持久化操作就是指，把数据放到持久化的介质中，同时提供增删改查操作，比如数据通过hibernate插入到数据库中。）<br>dao层隐藏了这种实现细节，更换数据库或者文件或者内存，对调用dao的更高层来说不受影响。 mapper和dao不同，mapper的目的是为了把关系数据库映射成java类（对象）。 因此，如果只有mapper没有dao层，那么一旦项目需要把数据保存到文件或者内存，那么调用mapper的高层就会受到影响。 一般的项目可能只会使用数据库作为数据存储，所以mapper和dao可以说上就是一个东西了。</p><h2 id="controller层"><a href="#controller层" class="headerlink" title="controller层"></a>controller层</h2><p>控制器，导入service层。因为service中的方法是我们使用到的，controller通过接收前端传过来的参数进行业务操作，在返回一个指定的路径或者数据表。用户在view中发送数据到controller层，然后controller根据用户请求，决定使用什么视图和数据进行表示。在这个过程中，controller会使用到service的一些业务逻辑处理，也就是数据库的操作。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>springboot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springboot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux实现进程通信的四种常见方式</title>
    <link href="/2021/11/09/linux%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%B8%B8%E8%A7%81%E6%96%B9%E5%BC%8F/"/>
    <url>/2021/11/09/linux%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%B8%B8%E8%A7%81%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>在linux下实现进程通信</p><h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><h2 id="操作系统IPC类别"><a href="#操作系统IPC类别" class="headerlink" title="操作系统IPC类别"></a>操作系统IPC类别</h2><p>操作系统内部的 IPC基本分为三个类别：</p><ol><li>共享内存 - Shared Memory；</li><li>消息传递 - Message Passing Interface；</li><li>管道 - Pipe</li></ol><h2 id="常见的四种IPC实践"><a href="#常见的四种IPC实践" class="headerlink" title="常见的四种IPC实践"></a>常见的四种IPC实践</h2><p>四种单机 IPC 方式进行学习和手动实践：</p><ol><li>管道；</li><li>信号-Signal；</li><li>消息传递；</li><li>共享内存</li></ol><h1 id="开始实验"><a href="#开始实验" class="headerlink" title="开始实验"></a>开始实验</h1><p>在开始实验之前，我们的所有操作都在/drive下</p><h2 id="实验一：软中断实验"><a href="#实验一：软中断实验" class="headerlink" title="实验一：软中断实验"></a>实验一：软中断实验</h2><ol><li>输入命令<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#具体的c文件可以自己定义！</span><br>vim homework1.c<br></code></pre></div></td></tr></table></figure></li><li>编写代码<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;signal.h&gt;</span></span><br><span class="hljs-comment">//fvoid int_func(int sig);</span><br><span class="hljs-keyword">int</span> k;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">int_func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sig)</span></span><br><span class="hljs-function"></span>&#123;<br>        k=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;int_func\n&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>        signal(SIGINT,int_func);<br>        k=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(k==<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello!\n&quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;OK!\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>保存之后输入下面的命令进行编译<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">gcc homework1.c -o homework1<br></code></pre></div></td></tr></table></figure></li><li>运行<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">./homework1<br></code></pre></div></td></tr></table></figure></li><li>运行结果<br><img src="%E5%AE%9E%E9%AA%8C1-1.png"><h2 id="实验二：用软中断实现父子进程同步"><a href="#实验二：用软中断实现父子进程同步" class="headerlink" title="实验二：用软中断实现父子进程同步"></a>实验二：用软中断实现父子进程同步</h2></li><li>输入命令<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#具体的c文件可以自己定义！</span><br>vim homework2.c<br></code></pre></div></td></tr></table></figure></li><li>编写代码<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;signal.h&gt;</span></span><br><span class="hljs-keyword">int</span> k1;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">int_fun1</span><span class="hljs-params">()</span></span>&#123;<br>        k1=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">int</span> k,p1;<br>        <span class="hljs-keyword">while</span>((p1=fork())==<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">if</span>(p1&gt;<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">for</span>(k=<span class="hljs-number">1</span>;k&lt;<span class="hljs-number">4</span>;k++)&#123;<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;how are you!\n&quot;</span>);<br>                        sleep(<span class="hljs-number">1</span>);<span class="hljs-comment">//延时函数，延时一秒</span><br>                &#125;<br>                kill(p1,<span class="hljs-number">12</span>);<br>                wait(<span class="hljs-number">0</span>);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;OK!\n&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>                signal(<span class="hljs-number">12</span>,int_fun1);<br>                k1=<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span>(k1==<span class="hljs-number">1</span>)<br>                &#123;<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i am child\n&quot;</span>);<br>                        sleep(<span class="hljs-number">1</span>);<br>                &#125;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Child exited!\n&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>保存之后输入下面的命令进行编译<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">gcc homework2.c -o homework2<br></code></pre></div></td></tr></table></figure></li><li>运行<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">./homework2<br></code></pre></div></td></tr></table></figure></li><li>结果<br><img src="%E5%AE%9E%E9%AA%8C2-1.png"><h2 id="实验三：无名管道的使用"><a href="#实验三：无名管道的使用" class="headerlink" title="实验三：无名管道的使用"></a>实验三：无名管道的使用</h2></li><li>输入命令<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#具体的c文件可以自己定义！</span><br>vim homework3.c<br></code></pre></div></td></tr></table></figure></li><li>编写代码<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">int</span> p1,fd[<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">char</span> outpipe[<span class="hljs-number">50</span>];<span class="hljs-comment">//定义读缓冲区</span><br>        <span class="hljs-keyword">char</span> inpipe[<span class="hljs-number">50</span>];<span class="hljs-comment">//定义写缓冲区</span><br>        pipe(fd);<span class="hljs-comment">//创建无名管道fd</span><br>        <span class="hljs-keyword">while</span>((p1=fork())==<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">if</span>(p1==<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-built_in">strcpy</span>(inpipe,<span class="hljs-string">&quot;this is a message!&quot;</span>);<br>                write(fd[<span class="hljs-number">1</span>],inpipe,<span class="hljs-number">50</span>);<span class="hljs-comment">//写信息到管道</span><br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><span class="hljs-comment">//父进程调用</span><br>        &#123;<br>                wait(<span class="hljs-number">0</span>);<br>                read(fd[<span class="hljs-number">0</span>],outpipe,<span class="hljs-number">50</span>);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,outpipe);<span class="hljs-comment">//显示读到的信息</span><br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>保存之后输入下面的命令进行编译<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">gcc homework3.c -o homework3<br></code></pre></div></td></tr></table></figure></li><li>运行<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">./homework3<br></code></pre></div></td></tr></table></figure></li><li>结果<br><img src="%E5%AE%9E%E9%AA%8C3-1.png"><h2 id="实验四：-消息队列通信"><a href="#实验四：-消息队列通信" class="headerlink" title="实验四： 消息队列通信"></a>实验四： 消息队列通信</h2></li><li>输入命令<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#具体的c文件可以自己定义！</span><br>vim Sndfile.c<br></code></pre></div></td></tr></table></figure></li><li>编写代码<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/msg.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXMSG 512</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">my_msg</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> my_msg_type;<br>  <span class="hljs-keyword">int</span> i;<br>  <span class="hljs-keyword">char</span> some_text[MAXMSG];<br>&#125;msg;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">int</span> msgid;<br>  <span class="hljs-keyword">char</span> buffer[BUFSIZ];<br>  msgid=msgget(<span class="hljs-number">12</span>,<span class="hljs-number">0666</span> | IPC_CREAT);<span class="hljs-comment">//创建消息队列</span><br>  <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Enter some text&quot;</span>);<br>        fgets(buffer,BUFSIZ,<span class="hljs-built_in">stdin</span>);<br>        msg.i++;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i=%d\n&quot;</span>,msg.i);<br>        msg.my_msg_type=<span class="hljs-number">3</span>;<br>        <span class="hljs-built_in">strcpy</span>(msg.some_text,buffer);<br>        msgsnd(msgid,&amp;msg,MAXMSG,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strncmp</span>(msg.some_text,<span class="hljs-string">&quot;end&quot;</span>,<span class="hljs-number">3</span>)==<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br><br>  &#125;<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>保存之后输入下面的命令进行编译<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">gcc Sndfile.c -o Sndfile<br></code></pre></div></td></tr></table></figure></li><li>运行<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">./Sndfile<br></code></pre></div></td></tr></table></figure></li><li>输出内容<br><img src="%E5%AE%9E%E9%AA%8C4-1.png"></li><li>输入命令<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#具体的c文件可以自己定义！</span><br>vim Rcvfile.c<br></code></pre></div></td></tr></table></figure></li><li>编写代码<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/msg.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXMSG 512</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">my_msg</span></span><br><span class="hljs-class">&#123;</span><br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> my_msg_type;<br>        <span class="hljs-keyword">int</span> i;<br>        <span class="hljs-keyword">char</span> some_text[MAXMSG];<br>&#125;msg;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">int</span> msgid;<br>msg.my_msg_type=<span class="hljs-number">3</span>;<br>        <span class="hljs-comment">//char buuffer[BUFSIZ];</span><br>        msgid=msgget(<span class="hljs-number">12</span>,<span class="hljs-number">0666</span> | IPC_CREAT);<span class="hljs-comment">//创建消息队列</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        msgrcv(msgid,&amp;msg,BUFSIZ,msg.my_msg_type,<span class="hljs-number">0</span>);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;you wrote:%s and i=%d\n&quot;</span>,msg.some_text,msg.i);<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strncmp</span>(msg.some_text,<span class="hljs-string">&quot;end&quot;</span>,<span class="hljs-number">3</span>)==<span class="hljs-number">0</span>)<br>                        <span class="hljs-keyword">break</span>;<br>        &#125;<br>msgctl(msgid,IPC_RMID,<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>输出内容<br><img src="%E5%AE%9E%E9%AA%8C4-2.png"></li></ol><h2 id="实验五：共享内存"><a href="#实验五：共享内存" class="headerlink" title="实验五：共享内存"></a>实验五：共享内存</h2><ol><li>编写代码<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//Rcvshm.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/shm.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> shmid;<br>    <span class="hljs-keyword">char</span> *viraddr;<br>    shmid=shmget(<span class="hljs-number">1234</span>,BUFSIZ,<span class="hljs-number">0666</span> | IPC_CREAT);<span class="hljs-comment">//创建共享内存</span><br>    viraddr=(<span class="hljs-keyword">char</span> *) shmat(shmid,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<span class="hljs-comment">//附接到共享内存</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;your message is :%s&quot;</span>,viraddr);<br>    shmdt(viraddr);<br>    shmctl(shmid,IPC_RMID,<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//Sndshm.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/shm.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> shmid;<br>    <span class="hljs-keyword">char</span> *viraddr;<br>    <span class="hljs-keyword">char</span> buffer[BUFSIZ];<br>    shmid=shmget(<span class="hljs-number">1234</span>,BUFSIZ,<span class="hljs-number">0666</span> | IPC_CREAT);<span class="hljs-comment">//创建共享内存</span><br>    viraddr=(<span class="hljs-keyword">char</span> *) shmat(shmid,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<span class="hljs-comment">//附接到共享内存</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Enter some text:&quot;</span>);<br>    fgets(buffer,BUFSIZ,<span class="hljs-built_in">stdin</span>);<span class="hljs-comment">//将标准输入送进缓冲区</span><br>    <span class="hljs-built_in">strcat</span>(viraddr,buffer);<span class="hljs-comment">//用追加的方式写共享内存</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strncmp</span>(buffer,<span class="hljs-string">&quot;end&quot;</span>,<span class="hljs-number">3</span>)==<span class="hljs-number">0</span>)<span class="hljs-comment">//当输入的字符串是end的时候终止循环</span><br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    shmdt(viraddr);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>实验结果<br><img src="%E5%AE%9E%E9%AA%8C5-1.png"><br><img src="%E5%AE%9E%E9%AA%8C5-2.png"></li></ol><h2 id="实验六：pv操作-以下代码参考超超博客，友链中有博客地址"><a href="#实验六：pv操作-以下代码参考超超博客，友链中有博客地址" class="headerlink" title="实验六：pv操作(以下代码参考超超博客，友链中有博客地址)"></a>实验六：pv操作(以下代码参考超超博客，友链中有博客地址)</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/shm.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/sem.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/wait.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RESOURCESNUM 4096</span><br><br><span class="hljs-comment">//函数声明</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">attach_shm</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//绑定共享内存</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">detach_shm</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//解绑共享内存</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">P</span><span class="hljs-params">(<span class="hljs-keyword">short</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> num)</span></span>;<span class="hljs-comment">//对某个信号量进行p操作</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">V</span><span class="hljs-params">(<span class="hljs-keyword">short</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> num)</span></span>;<span class="hljs-comment">//对某个信号量进行v操作</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">readMessage</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>;<span class="hljs-comment">//读取数据，id为0，表示A在操作，id为2，表示B在操作</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">writeMessage</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>;<span class="hljs-comment">//写入数据，id为0，表示A在操作，id为2，表示B在操作</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">A</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//进程A</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">B</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//进程B</span><br><br><br><span class="hljs-comment">//数据结构声明</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Buffer</span>&#123;</span><br>    <span class="hljs-comment">//共享内存缓冲区资源的循环队列</span><br>    <span class="hljs-keyword">int</span> message[RESOURCESNUM];<br>    <span class="hljs-keyword">int</span> f;<br>    <span class="hljs-keyword">int</span> r;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">semun</span>&#123;</span><br>    <span class="hljs-comment">//信号量数据结构</span><br>    <span class="hljs-keyword">int</span> value;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">MUTEX</span>&#123;</span><br>    <span class="hljs-comment">//信号量集</span><br>    SA,               <span class="hljs-comment">//M1操作的信号量</span><br>    SB,               <span class="hljs-comment">//M2操作的信号量</span><br>    S                 <span class="hljs-comment">//信号量相关信号量</span><br>&#125;;<br><br><span class="hljs-comment">//公共变量声明</span><br><span class="hljs-keyword">int</span> semid;<span class="hljs-comment">//信号量集合描述符</span><br><span class="hljs-keyword">int</span> shmid[<span class="hljs-number">2</span>];<span class="hljs-comment">//共享空间描述符，M1,M2各占一个空间</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Buffer</span> *<span class="hljs-title">shm</span>[2];</span><span class="hljs-comment">//共享空间首地址</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Buffer</span> <span class="hljs-title">M</span>[2];</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *argv[])</span></span>&#123;<br>    <span class="hljs-comment">//记录父进程pid</span><br>    <span class="hljs-keyword">pid_t</span> ppid = <span class="hljs-built_in">getpid</span>();<br>    <span class="hljs-comment">//信号集名字，信号集中信号量的个数，信号量集合的权限</span><br>    semid = <span class="hljs-built_in">semget</span>((<span class="hljs-keyword">key_t</span>)<span class="hljs-number">1234</span>, S, IPC_CREAT | <span class="hljs-number">0600</span>); <span class="hljs-comment">//创建信号量</span><br>    <span class="hljs-keyword">if</span> (semid == <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;semget&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 初始化信号量</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">semun</span> <span class="hljs-title">s</span>;</span><br>    <span class="hljs-comment">//初始时，允许A执行</span><br>    s.value = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">semctl</span>(semid, SA, SETVAL, s);<br>    <span class="hljs-comment">//初始时，不允许B执行</span><br>    s.value = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">semctl</span>(semid, SB, SETVAL, s);<br><br>    <span class="hljs-comment">//创建共享内存</span><br>    shmid[<span class="hljs-number">0</span>] = <span class="hljs-built_in">shmget</span>((<span class="hljs-keyword">key_t</span>)<span class="hljs-number">1234</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(M[<span class="hljs-number">0</span>]), <span class="hljs-number">0666</span> | IPC_CREAT);<br>    shmid[<span class="hljs-number">1</span>] = <span class="hljs-built_in">shmget</span>((<span class="hljs-keyword">key_t</span>)<span class="hljs-number">5678</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(M[<span class="hljs-number">1</span>]), <span class="hljs-number">0666</span> | IPC_CREAT);<br><br>    <span class="hljs-keyword">if</span> (shmid[<span class="hljs-number">0</span>] == <span class="hljs-number">-1</span> || shmid[<span class="hljs-number">1</span>] == <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;shmget failed\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br>    <span class="hljs-built_in">attach_shm</span>();<br>    <span class="hljs-comment">//初始化共享内存</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++)&#123;<br>        <span class="hljs-built_in">memset</span>(shm[i]-&gt;message, <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(shm[i]-&gt;message));<br>        shm[i]-&gt;f = <span class="hljs-number">0</span>;<br>        shm[i]-&gt;r = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">//创建3个进程：1个父进程 + 1个A + 1个B</span><br>    <span class="hljs-keyword">pid_t</span> child_pid[<span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++)&#123;<br>        child_pid[i] = fork();<br>        <span class="hljs-comment">//子进程</span><br>        <span class="hljs-keyword">if</span> (child_pid[i] == <span class="hljs-number">0</span>) <br>        &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//A</span><br>    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">A</span>();<br>    &#125;<br>    <span class="hljs-comment">//B</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">B</span>();<br>    &#125;<br><span class="hljs-comment">//父进程</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">getpid</span>() == ppid) &#123;<br>        <span class="hljs-comment">//等待子进程结束</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-built_in">waitpid</span>(child_pid[i], <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-built_in">detach_shm</span>();<br>        <span class="hljs-comment">//删除共享内存</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">shmctl</span>(shmid[<span class="hljs-number">0</span>], IPC_RMID, <span class="hljs-number">0</span>) == <span class="hljs-number">-1</span> || <span class="hljs-built_in">shmctl</span>(shmid[<span class="hljs-number">1</span>], IPC_RMID, <span class="hljs-number">0</span>) == <span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;shmctl(IPC_RMID) failed\n&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">attach_shm</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//将共享内存连接到当前进程的地址空间</span><br>    shm[<span class="hljs-number">0</span>] = (struct Buffer *)<span class="hljs-built_in">shmat</span>(shmid[<span class="hljs-number">0</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>    shm[<span class="hljs-number">1</span>] = (struct Buffer *)<span class="hljs-built_in">shmat</span>(shmid[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (shm[<span class="hljs-number">0</span>] == (struct Buffer *)<span class="hljs-number">-1</span> || shm[<span class="hljs-number">1</span>] == (struct Buffer *)<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;shmat failed\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">detach_shm</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//把共享内存从当前进程中分离</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">shmdt</span>((<span class="hljs-keyword">void</span> *)shm[<span class="hljs-number">0</span>]) == <span class="hljs-number">-1</span> || <span class="hljs-built_in">shmdt</span>((<span class="hljs-keyword">void</span> *)shm[<span class="hljs-number">1</span>]) == <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;shmdt failed\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">关于sembuf的结构以及属性的具体含义如下：</span><br><span class="hljs-comment">    struct sembuf&#123;</span><br><span class="hljs-comment">        short sem_num;//除非使用一组信号量，否则它为0</span><br><span class="hljs-comment">        short sem_op;//信号量在一次操作中需要改变的数据，通常是两个数，一个是-1，即P（等待）操作，</span><br><span class="hljs-comment">                        //一个是+1，即V（发送信号）操作。</span><br><span class="hljs-comment">        short sem_flg;//通常为SEM_UNDO,使操作系统跟踪信号，</span><br><span class="hljs-comment">                        //并在进程没有释放该信号量而终止时，操作系统释放信号量</span><br><span class="hljs-comment">    &#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">P</span><span class="hljs-params">(<span class="hljs-keyword">short</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> num)</span></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sembuf</span> <span class="hljs-title">sb</span> =</span>&#123;num, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-comment">//修改集合中，一个或多个信号量值</span><br>    <span class="hljs-built_in">semop</span>(semid, &amp;sb, <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">V</span><span class="hljs-params">(<span class="hljs-keyword">short</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> num)</span></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sembuf</span> <span class="hljs-title">sb</span> =</span> &#123;num, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-built_in">semop</span>(semid, &amp;sb, <span class="hljs-number">1</span>);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">readMessage</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>&#123;<br>    <span class="hljs-comment">// id = 0，读取M[1]，id = 1，读取M[0]</span><br>    <span class="hljs-keyword">int</span> message = <span class="hljs-number">0</span>;<br>    message = shm[-id + <span class="hljs-number">1</span>]-&gt;message[shm[-id + <span class="hljs-number">1</span>]-&gt;f];<br>    shm[-id + <span class="hljs-number">1</span>]-&gt;f = (shm[-id + <span class="hljs-number">1</span>]-&gt;f + <span class="hljs-number">1</span>) % RESOURCESNUM;<br>    <span class="hljs-comment">// printf(&quot;M%d -&gt; f = %d\n&quot;, -id + 2, shm[-id + 1]-&gt;f);</span><br>    <span class="hljs-keyword">return</span> message;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">writeMessage</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>&#123;<br>    <span class="hljs-comment">//随机生成一个范围在[1,4096]的message</span><br>    <span class="hljs-keyword">int</span> message = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">4096</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//id为0，向M[0]写入，id为1，向M[1]写入</span><br>    shm[id]-&gt;message[shm[id]-&gt;r] = message;<br>    shm[id]-&gt;r = (shm[id]-&gt;r + <span class="hljs-number">1</span>) % RESOURCESNUM;<br>    <span class="hljs-comment">// printf(&quot;M%d -&gt; r = %d\n&quot;, id + 1, shm[id]-&gt;r);</span><br>    <span class="hljs-keyword">return</span> message;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">A</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">attach_shm</span>();<br><span class="hljs-comment">//这里让A执行5次</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> m = <span class="hljs-number">0</span>; m &lt; <span class="hljs-number">5</span>; m++)&#123;<br>        <span class="hljs-built_in">P</span>(SA);<br>        <span class="hljs-comment">//countOfM1：当前M1中元素个数(队列，求队列中元素的个数)</span><br>        <span class="hljs-keyword">int</span> countOfM1 = (shm[<span class="hljs-number">0</span>]-&gt;r - shm[<span class="hljs-number">0</span>]-&gt;f + RESOURCESNUM) % RESOURCESNUM;<br>        <span class="hljs-comment">//currentResidueNum：当前最多写入个数</span><br>        <span class="hljs-keyword">int</span> currentResidueNum = RESOURCESNUM - countOfM1;<br>        <span class="hljs-comment">//每次添加的数量不超过10</span><br>        <span class="hljs-keyword">int</span> randInt = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">10</span> + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> times = randInt;<br>        <span class="hljs-comment">//如果当前最多写入个数小于10，那就写当前最多写入个数</span><br>        <span class="hljs-keyword">if</span>(currentResidueNum&lt;<span class="hljs-number">10</span>)&#123;<br>            times=currentResidueNum;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; times; i++)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;A：发送常规信息到 M1 ，信息为%d\n&quot;</span>, <span class="hljs-built_in">writeMessage</span>(<span class="hljs-number">0</span>));<br>        &#125;<br>        <span class="hljs-comment">//最开始M2是为空的，因为B没有向里面写数据。所以只在M2有消息的时候才读取</span><br>        <span class="hljs-keyword">if</span> (shm[<span class="hljs-number">1</span>]-&gt;f != shm[<span class="hljs-number">1</span>]-&gt;r)&#123;<br>            <span class="hljs-comment">//当前M2中元素个数(队列，求队列中元素的个数)</span><br>            <span class="hljs-keyword">int</span> countOfM2 = (shm[<span class="hljs-number">1</span>]-&gt;r - shm[<span class="hljs-number">1</span>]-&gt;f + RESOURCESNUM) % RESOURCESNUM;<br>            <span class="hljs-comment">//随机读取，但是不能够超过M2中有的数量</span><br>            <span class="hljs-keyword">int</span> times = <span class="hljs-built_in">rand</span>() % countOfM2 + <span class="hljs-number">1</span>;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; times; i++)<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;A 从 M2 中消费控制信息，信息为 %d \n&quot;</span>, <span class="hljs-built_in">readMessage</span>(<span class="hljs-number">0</span>));<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;M2中没有信息！ \n&quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">V</span>(SB);<br>    &#125;<br>    <span class="hljs-built_in">detach_shm</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">B</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">attach_shm</span>();<br>    <span class="hljs-comment">//这里让B执行5次</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> m = <span class="hljs-number">0</span>; m &lt; <span class="hljs-number">5</span>; m++)&#123;<br>        <span class="hljs-built_in">P</span>(SB);<br>        <span class="hljs-comment">//当前M2中元素个数</span><br>        <span class="hljs-keyword">int</span> countOfM2 = (shm[<span class="hljs-number">0</span>]-&gt;r - shm[<span class="hljs-number">0</span>]-&gt;f + RESOURCESNUM) % RESOURCESNUM;<br>        <span class="hljs-comment">//currentResidueNum：当前最多写入个数</span><br>        <span class="hljs-keyword">int</span> currentResidueNum = RESOURCESNUM - countOfM2;<br>        <span class="hljs-comment">//取一个小于10的随机数</span><br>        <span class="hljs-keyword">int</span> randInt = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">10</span> + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> times = randInt;<br>        <span class="hljs-comment">//如果当前剩余位置小于10</span><br>        <span class="hljs-keyword">if</span>(currentResidueNum&lt;<span class="hljs-number">10</span>)&#123;<br>            times=currentResidueNum;<br>        &#125;<br>        <br>        <span class="hljs-comment">//向M2写times个信息</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; times; i++)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;B 发送控制信息到 M2 ，信息为%d\n&quot;</span>, <span class="hljs-built_in">writeMessage</span>(<span class="hljs-number">1</span>));<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> countOfM1 = (shm[<span class="hljs-number">0</span>]-&gt;r - shm[<span class="hljs-number">0</span>]-&gt;f + RESOURCESNUM) % RESOURCESNUM;<br>        <span class="hljs-comment">//随机读取，但是不能够超过M2中有的数量</span><br>        times = <span class="hljs-built_in">rand</span>() % countOfM1 + <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">//消费信息，B消费M1中的信息，但是不能超过M1拥有的信息数量</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; times; i++)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;B 从 M1 中消费常规信息，信息为 %d \n&quot;</span>, <span class="hljs-built_in">readMessage</span>(<span class="hljs-number">1</span>));<br>        &#125;<br><br>        <span class="hljs-built_in">V</span>(SA);<br>    &#125;<br>    <span class="hljs-built_in">detach_shm</span>();<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
      <category>对linux的底层理解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux添加内核模块（实现系统调用）</title>
    <link href="/2021/11/09/%E6%B7%BB%E5%8A%A0%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%EF%BC%88%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E8%B0%83%E7%94%A8%EF%BC%89/"/>
    <url>/2021/11/09/%E6%B7%BB%E5%8A%A0%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%EF%BC%88%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E8%B0%83%E7%94%A8%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>在向linux内核中添加一个内核模块之前，需要了解进程调用。</p><h1 id="一些预备知识"><a href="#一些预备知识" class="headerlink" title="一些预备知识"></a>一些预备知识</h1><h2 id="进程调用"><a href="#进程调用" class="headerlink" title="进程调用"></a>进程调用</h2><p>它是应用程序和操作系统内核进行交互的最直接、最原始的接口和通道。在遵循一定的规则下，它让进程可以享受到操作系统内核提供的服务，例如申请 I/O 资源以访问相关的硬件、申请共享内存以用于 IPC 等等。<br>系统调用在我们的程序运行中，经常被直接或者间接使用到。我们在程序中经常用到的库函数，大部分是对相关系统调用的进一步抽象和封装，以提高系统调用的使用便利性，例如：在 C/C++语言里，分配虚拟内存的函数 malloc()，实质上是基于晦涩难懂的系统调用brk()/sbrk()而构造的。<br>一旦一个应用程序执行系统调用成功，其 CPU 运行状态将发生变化，由用户层的 Ring3 转移至内核层的 Ring 0（大家可以去搜索一下 X86 体系结构下的 Ring 3 和 Ring 0 的概念，简单来说，内核层次的代码为特权指令，只能在 CPU 的 Ring 0 状态下运行）。如果系统调用顺利完成，CPU 则会由 Ring 0 状态切换回至 Ring 3 状态。<br><strong>添加内核模块</strong>的目的，就是增加一个自己设计的系统调用，并让对应的进程运行在此新内核之上，享受到该系统调用所提供的（简单）服务。</p><h2 id="内核模块"><a href="#内核模块" class="headerlink" title="内核模块"></a>内核模块</h2><p>内核模块的编写方式不同于大家在应用层的程序编写方式——main 函数——从头到尾写下去，而是有其固定的编程框架。一般在通过一个特别的 makefile 文件对其编译成功后，会输出后缀名为 ko 的内核模块文件，再利用 insmod 命令将其加载进正在运行的内核即可。（还有一种静态方法可以添加进程调用——源码，找到对应的源码位置，加入新系统调用的入口和相关执行逻辑，之后，重新编译和安装整个新内核）<br>**最后，请注意，此内核模块的功能是：从真正意义上为当前操作系统设计一个新的系统调用（在此内核模块的源码里有相应的加入“新系统调用“的程序语句），然后供上层应用程序所使用（你的应用程序调用了此”接口“），绝不是在内核模块的加载过程中简单地用 printk 来进行一次字符串输出。 **</p><h1 id="正文（添加内核模块）"><a href="#正文（添加内核模块）" class="headerlink" title="正文（添加内核模块）"></a>正文（添加内核模块）</h1><h2 id="1-查看syscall-table"><a href="#1-查看syscall-table" class="headerlink" title="1.查看syscall_table"></a>1.查看syscall_table</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo cat /proc/kallsyms | grep sys_call_table<br></code></pre></div></td></tr></table></figure><p><img src="syscall_table.png"><br>可以发现，syscall_table的地址是ffffffffb82013a0</p><h2 id="2-查看可用的系统调用号"><a href="#2-查看可用的系统调用号" class="headerlink" title="2. 查看可用的系统调用号"></a>2. 查看可用的系统调用号</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">vim /usr/include/asm/unistd_32.h<br></code></pre></div></td></tr></table></figure><p>我使用的是384号。</p><h2 id="3-创建c文件和Makefile文件"><a href="#3-创建c文件和Makefile文件" class="headerlink" title="3. 创建c文件和Makefile文件"></a>3. 创建c文件和Makefile文件</h2><h3 id="1-在任意位置创建一个文件夹"><a href="#1-在任意位置创建一个文件夹" class="headerlink" title="1. 在任意位置创建一个文件夹"></a>1. 在任意位置创建一个文件夹</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">mkdir /LKM<br></code></pre></div></td></tr></table></figure><h3 id="2-然后进入文件夹"><a href="#2-然后进入文件夹" class="headerlink" title="2. 然后进入文件夹"></a>2. 然后进入文件夹</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /LKM<br></code></pre></div></td></tr></table></figure><h3 id="3-新建c文件，我新建的是zengshangren20192333011-c"><a href="#3-新建c文件，我新建的是zengshangren20192333011-c" class="headerlink" title="3. 新建c文件，我新建的是zengshangren20192333011.c"></a>3. 新建c文件，我新建的是zengshangren20192333011.c</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#创建文件命令：</span><br>vim zengshangren20192333011.c<br></code></pre></div></td></tr></table></figure><p>代码如下，注意在对应地方修改成自己的信息！</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/kernel.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/init.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/module.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/sched.h&gt;</span></span><br>  <br>MODULE_LICENSE(<span class="hljs-string">&quot;Dual BSD/GPL&quot;</span>);<br> <br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_CALL_TABLE_ADDRESS 0xffffffffb82013a0   <span class="hljs-comment">//sys_call_table对应的地址</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NUM 384  <span class="hljs-comment">//系统调用号为384</span></span><br><span class="hljs-keyword">int</span> orig_cr0;  <span class="hljs-comment">//用来存储cr0寄存器原来的值</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *sys_call_table_my=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">int</span><span class="hljs-params">(*anything_saved)</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;  <span class="hljs-comment">//定义一个函数指针，用来保存一个系统调用</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">clear_cr0</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-comment">//使cr0寄存器的第17位设置为0（内核空间可写）</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> cr0=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> ret;<br>    <span class="hljs-function"><span class="hljs-keyword">asm</span> <span class="hljs-title">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;movq %%cr0,%%rax&quot;</span>:<span class="hljs-string">&quot;=a&quot;</span>(cr0))</span></span>;<span class="hljs-comment">//将cr0寄存器的值移动到eax寄存器中，同时输出到cr0变量中</span><br>    ret=cr0;<br>    cr0&amp;=<span class="hljs-number">0xfffffffffffeffff</span>;<span class="hljs-comment">//将cr0变量值中的第17位清0,将修改后的值写入cr0寄存器</span><br>    <span class="hljs-function"><span class="hljs-keyword">asm</span> <span class="hljs-title">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;movq %%rax,%%cr0&quot;</span>::<span class="hljs-string">&quot;a&quot;</span>(cr0))</span></span>;<span class="hljs-comment">//将cr0变量的值作为输入，输入到寄存器eax中，同时移动到寄存器cr0中</span><br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setback_cr0</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> <span class="hljs-comment">//使cr0寄存器设置为内核不可写</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">asm</span> <span class="hljs-title">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;movq %%rax,%%cr0&quot;</span>::<span class="hljs-string">&quot;a&quot;</span>(val))</span></span>;<br>&#125;<br> <br><span class="hljs-function">asmlinkage <span class="hljs-keyword">long</span> <span class="hljs-title">sys_mycall</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-comment">//定义自己的系统调用</span></span><br><span class="hljs-function"></span>&#123;   <br>    printk(<span class="hljs-string">&quot;模块系统调用-当前pid：%d，当前comm:%s\n&quot;</span>,current-&gt;pid,current-&gt;comm);<br>    printk(<span class="hljs-string">&quot;学号：20192333011\n姓名：曾尚仁\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> current-&gt;pid;    <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> __init <span class="hljs-title">call_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    sys_call_table_my=(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>*)(SYS_CALL_TABLE_ADDRESS);<br>    printk(<span class="hljs-string">&quot;call_init......\n&quot;</span>);<br>    anything_saved=(<span class="hljs-keyword">int</span>(*)(<span class="hljs-keyword">void</span>))(sys_call_table_my[NUM]);<span class="hljs-comment">//保存系统调用表中的NUM位置上的系统调用</span><br>    orig_cr0=clear_cr0();<span class="hljs-comment">//使内核地址空间可写</span><br>    sys_call_table_my[NUM]=(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) &amp;sys_mycall;<span class="hljs-comment">//用自己的系统调用替换NUM位置上的系统调用</span><br>    setback_cr0(orig_cr0);<span class="hljs-comment">//使内核地址空间不可写</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __exit <span class="hljs-title">call_exit</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    printk(<span class="hljs-string">&quot;call_exit......\n&quot;</span>);<br>    orig_cr0=clear_cr0();<br>    sys_call_table_my[NUM]=(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)anything_saved;<span class="hljs-comment">//将系统调用恢复</span><br>    setback_cr0(orig_cr0);<br>&#125;<br> <br>module_init(call_init);<br>module_exit(call_exit);<br></code></pre></div></td></tr></table></figure><h3 id="4-新建Makefile文件，注意第一个字母一定要大写！"><a href="#4-新建Makefile文件，注意第一个字母一定要大写！" class="headerlink" title="4. 新建Makefile文件，注意第一个字母一定要大写！"></a>4. 新建Makefile文件，注意第一个字母一定要大写！</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">obj-m += zengshangren20192333011.o<br>KERNELBUILD +=/usr/src/linux-headers-5.4.0-88-generic<br>all:<br>        make -C <span class="hljs-variable">$&#123;KERNELBUILD&#125;</span> M=<span class="hljs-variable">$&#123;shell pwd&#125;</span> modules<br>clean:<br>        rm -f *.ko *.o *.mod.o *mod.c *.symvers<br>CONFIG_MODULE_SIG=n<br></code></pre></div></td></tr></table></figure><p>注意：</p><ul><li>最后一句CONFIG_MODULE_SIG=n，是由于Linux内核3.7之后添加了内核签名机制，现在的内核只加载带有公钥的合法模块，因此可以尝试引入公钥mokutil –import public_key.der。当然，为了方便，Linux中默认CONFIG_MODULE_SIG = y即签名开启状态，因此可以在内核代码的config文件中找到并将其改为CONFIG_MODULE_SIG = n<br>这样就不会报错啦。如果有时间还是要学一学如何签名。</li><li>注意Makefile的大写字母M</li></ul><h2 id="4-编译Makefile文件"><a href="#4-编译Makefile文件" class="headerlink" title="4. 编译Makefile文件"></a>4. 编译Makefile文件</h2><p>直接在/LKM下输入命令“make”</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">make<br></code></pre></div></td></tr></table></figure><h2 id="5-添加、移除模块"><a href="#5-添加、移除模块" class="headerlink" title="5. 添加、移除模块"></a>5. 添加、移除模块</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#添加模块</span><br>insmod zengshangren20192333011.ko<br><br><span class="hljs-comment">#移除模块</span><br>rmmod zengshangren20192333011.ko<br></code></pre></div></td></tr></table></figure><h2 id="6-如何查看模块是否被添加？"><a href="#6-如何查看模块是否被添加？" class="headerlink" title="6. 如何查看模块是否被添加？"></a>6. 如何查看模块是否被添加？</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">lsmod<br></code></pre></div></td></tr></table></figure><p><img src="insertSuccess.png"></p><h2 id="7-在应用层调用"><a href="#7-在应用层调用" class="headerlink" title="7. 在应用层调用"></a>7. 在应用层调用</h2><p>编写homework.c</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;linux/kernel.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> x = <span class="hljs-number">0</span>;<br>        x = syscall(<span class="hljs-number">384</span>);        <span class="hljs-comment">//测试384号系统调用</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;zengshangren syscall : %ld\n&quot;</span>, x);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h2 id="8-编译并运行"><a href="#8-编译并运行" class="headerlink" title="8. 编译并运行"></a>8. 编译并运行</h2><p>！<a href="gccHomework.png"></a></p><h2 id="查看是否添加成功"><a href="#查看是否添加成功" class="headerlink" title="查看是否添加成功"></a>查看是否添加成功</h2><p>输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">dmesg<br></code></pre></div></td></tr></table></figure><p>结果如下<br><img src="result.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>远程连接linux运行jar包，在关闭终端后jar包停止运行怎么办？</title>
    <link href="/2021/11/08/%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5linux%E8%BF%90%E8%A1%8Cjar%E5%8C%85%EF%BC%8C%E5%9C%A8%E5%85%B3%E9%97%AD%E7%BB%88%E7%AB%AF%E5%90%8Ejar%E5%8C%85%E5%81%9C%E6%AD%A2%E8%BF%90%E8%A1%8C%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F/"/>
    <url>/2021/11/08/%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5linux%E8%BF%90%E8%A1%8Cjar%E5%8C%85%EF%BC%8C%E5%9C%A8%E5%85%B3%E9%97%AD%E7%BB%88%E7%AB%AF%E5%90%8Ejar%E5%8C%85%E5%81%9C%E6%AD%A2%E8%BF%90%E8%A1%8C%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>普通运行jar包的命令：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#使用这种方式，在远程连接的窗口关闭后，这个jar包开启的进程也随之关闭</span><br>java -jar xxx.jar <br></code></pre></div></td></tr></table></figure><p>解决方法1：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#使用这种方式表示ssh窗口不被锁定，但是关闭窗口的时候，程序还是会退出</span><br>java -jar xxx.jar &amp;<br></code></pre></div></td></tr></table></figure><p>解决方法2：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#使用这种方式表示不挂断运行命令行，当账号退出或者关闭终端的时候，程序仍然运行</span><br><span class="hljs-comment">#当用nohup命令执行jar的时候，改作业所有输出被重定向到nohup.out的文件中，除非指定另外的输出文件</span><br>nohup java -jar xxx.jar &amp;<br></code></pre></div></td></tr></table></figure><p>解决方法3：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#表示把所有的启动日志 记录到temp.txt文件中</span><br>nohup java -jar xxx.jar &gt;/usr/<span class="hljs-built_in">local</span>/temp.txt &amp;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
      <category>常见应用的安装与使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker下载太慢，更换镜像源</title>
    <link href="/2021/11/07/docker%E4%B8%8B%E8%BD%BD%E5%A4%AA%E6%85%A2%EF%BC%8C%E6%9B%B4%E6%8D%A2%E9%95%9C%E5%83%8F%E6%BA%90/"/>
    <url>/2021/11/07/docker%E4%B8%8B%E8%BD%BD%E5%A4%AA%E6%85%A2%EF%BC%8C%E6%9B%B4%E6%8D%A2%E9%95%9C%E5%83%8F%E6%BA%90/</url>
    
    <content type="html"><![CDATA[<h1 id="比较快的镜像源"><a href="#比较快的镜像源" class="headerlink" title="比较快的镜像源"></a>比较快的镜像源</h1><table><thead><tr><th>网站</th><th>网址</th></tr></thead><tbody><tr><td>网易云</td><td><a href="https://hub-mirror.c.163.com/">https://hub-mirror.c.163.com</a></td></tr><tr><td>百度云</td><td><a href="https://mirror.baidubce.com/">https://mirror.baidubce.com</a></td></tr><tr><td>阿里云</td><td><a href="https://ustc-edu-cn.mirror.aliyuncs.com/">https://ustc-edu-cn.mirror.aliyuncs.com</a></td></tr></tbody></table><h1 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h1><p>编辑 /etc/docker/daemon.json 配置文件</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">创建配置文件目录<br>$ sudo mkdir /etc/docker<br><br>编辑配置文件，如果文件不存在，需要自己创建一个。<br>$ sudo vim /etc/docker/daemon.json<br><br>将配置信息粘贴到配置文件中，配置信息为 json 格式，可以根据实际需要设置多个国内的镜像服务器。<br>&#123;<br>  <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<br><span class="hljs-string">&quot;https://ustc-edu-cn.mirror.aliyuncs.com&quot;</span><br>  ]<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="重启docker服务"><a href="#重启docker服务" class="headerlink" title="重启docker服务"></a>重启docker服务</h1><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ sudo systemctl daemon-reload <br>$ sudo systemctl restart docker<br></code></pre></div></td></tr></table></figure><h1 id="查看镜像源"><a href="#查看镜像源" class="headerlink" title="查看镜像源"></a>查看镜像源</h1><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ sudo docker info<br></code></pre></div></td></tr></table></figure><p>如果看到相关网址已经更改即修改成功！</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
      <category>常见应用的安装与使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux|ubuntu 安装jdk</title>
    <link href="/2021/11/07/linux%E4%B8%8B%E5%AE%89%E8%A3%85jdk/"/>
    <url>/2021/11/07/linux%E4%B8%8B%E5%AE%89%E8%A3%85jdk/</url>
    
    <content type="html"><![CDATA[<h1 id="jdk的安装目录"><a href="#jdk的安装目录" class="headerlink" title="jdk的安装目录"></a>jdk的安装目录</h1><p>linux中最标准的java jdk安装目录是：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">/usr/<span class="hljs-built_in">local</span>/java/<br></code></pre></div></td></tr></table></figure><p>在/usr/local下创建一个名为java的文件夹</p><h1 id="下载jdk"><a href="#下载jdk" class="headerlink" title="下载jdk"></a>下载jdk</h1><p><strong>一、去官网选择自己所需的jdk</strong><br>官网地址：<a href="https://www.oracle.com/java/technologies/downloads/">下载地址</a></p><p>例如，我选择的是jdk17<br><img src="https://img-blog.csdnimg.cn/e05848f9b4a84b4da5f2ccbc6c5d4c7a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pu-5bCa5LuB,size_20,color_FFFFFF,t_70,g_se,x_16" alt="选择合适的jdk"><br><strong>二、复制红框的链接。</strong><br>复制红框的链接后，进入linux系统中/usr/local/java/<br>然后敲如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">wget https://download.oracle.com/java/17/latest/jdk-17_linux-x64_bin.tar.gz<br></code></pre></div></td></tr></table></figure><p>注意，wget后面的链接是你刚刚复制的链接！</p><h1 id="安装jdk"><a href="#安装jdk" class="headerlink" title="安装jdk"></a>安装jdk</h1><p><strong>一、解压</strong><br>下载了上面的jdk后，会在/usr/local/java中看见这个文件，随后解压：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">tar zxf xxx.tar.gz <br></code></pre></div></td></tr></table></figure><p>xxx修改成对应的包的文件名即可<br>解压成功后可以删除这个包</p><p><strong>二、配置环境变量</strong><br>修改相关配置文件</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">vim /etc/profile<br></code></pre></div></td></tr></table></figure><p>打开文件后再末尾添加：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> JAVA17_HOME=/jdk17/jdk-17.0.1<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$JAVA17_HOME</span>/bin<br></code></pre></div></td></tr></table></figure><p>注意修改对应的版本。我这里是17。<br>最后输入命令让配置文件生效：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> /etc/profile<br></code></pre></div></td></tr></table></figure><p><strong>三、查看java版本</strong><br>输入命令</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">java -version<br></code></pre></div></td></tr></table></figure><p>查看到对应java版本即安装结束</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
      <category>常见应用的安装与使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
