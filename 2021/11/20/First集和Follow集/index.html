

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">First集和Follow集</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：4 天前
                
              </p>
            
            <div class="markdown-body">
              <h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><h2 id="串首终结符集（First）"><a href="#串首终结符集（First）" class="headerlink" title="串首终结符集（First）"></a>串首终结符集（First）</h2><p>定义：给定一个文法符号α，α的串首终结符集First(α)被定义为可以从α推导出的所有串首终结符构成的集合。<br>串首终结符意思就是符号串的首字符是终结符，所以由 α 推导出的所有首字母是终结符的文法符号串，这些终结符首字母组成的集合就是FIRST(α)。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>例如一个文法符号串 BCDe, 其中 B C D 都是非终结符，e 是终结符。</p>
<ol>
<li>求产生式右侧BCDe的First集合，首先要求出B能推导多少个串首终结符。这个就要求出First(B)</li>
<li>如果B能够推出空串ε，即B-&gt;ε，那么B就是可以消除的，文法符号串BCDe相当于CDe，所以又要求First(C).</li>
<li>如此循环往复。</li>
</ol>
<h3 id="因此对于一个文法符号串-X1X2-…-Xn，求解串首终结符集-FIRST-X1X2-…-Xn-算法"><a href="#因此对于一个文法符号串-X1X2-…-Xn，求解串首终结符集-FIRST-X1X2-…-Xn-算法" class="headerlink" title="因此对于一个文法符号串 X1X2 … Xn，求解串首终结符集 FIRST(X1X2 … Xn)算法"></a>因此对于一个文法符号串 X1X2 … Xn，求解串首终结符集 FIRST(X1X2 … Xn)算法</h3><ol>
<li>遍历这个文法符号串，然后判断当前文法符号串中的字符 Xi (i属于1到n)。</li>
<li>如果 Xi 是终结符，那么它的串首终结符集FIRST(Xi)中就只有它自己，将FIRST(Xi)加入FIRST(X1X2 … Xn) 中；因为FIRST(Xi)也不可能包含空串 ε，不用再向下遍历，循环到此为止，得到最终的串首终结符集FIRST(X1X2 … Xn)。</li>
<li>如果 Xi 是非终结符，那么就将它的串首终结符集FIRST(Xi)加入FIRST(X1X2 … Xn) 中。</li>
</ol>
<ul>
<li>如果FIRST(Xi)包含空串ε，那么再向下遍历一个字符；但是如果 Xi 已经是最后一个字符了，那就说明整个文法符号串 X1X2 … Xn可以推导出空串ε，因此将空串ε加到FIRST(X1X2 … Xn) 中。</li>
<li>如果FIRST(Xi)不包含空串ε，不用再向下遍历，循环到此为止，得到最终的串首终结符集FIRST(X1X2 … Xn)。如求非终结符A 的串首终结符集FIRST(A)，其实就是看这个非终结符A 能够推导的所有首字符是终结符的文法符号串，那么就是看这个非终结符A 的产生式组。</li>
</ul>
<h3 id="非终结符本身就属于一个特殊的文法符号串"><a href="#非终结符本身就属于一个特殊的文法符号串" class="headerlink" title="非终结符本身就属于一个特殊的文法符号串"></a>非终结符本身就属于一个特殊的文法符号串</h3><p>而求解文法符号串的串首终结符集，其实就是要知道文法符号串中每个字符的串首终结符集:</p>
<ol>
<li>对于终结符，它的串首终结符集就是它自己。</li>
<li>对于非终结符，它的串首终结符集是要通过它对应的产生式组计算得来的。</li>
<li>再判断当前字符对应的串首终结符集包不包含空串，来决定要不要添加文法符号串中下一个字符的串首终结符集。</li>
</ol>
<h2 id="后继符号集（Follow）"><a href="#后继符号集（Follow）" class="headerlink" title="后继符号集（Follow）"></a>后继符号集（Follow）</h2><p>定义：对于任一非终结符A，它的后继符号集就是由文法G推导出来的所有句型，可以出现在非终结符A后边的终结符的集合，记为FOLLOW(A)。</p>
<h3 id="求非终结符A的后继符号集算法："><a href="#求非终结符A的后继符号集算法：" class="headerlink" title="求非终结符A的后继符号集算法："></a>求非终结符A的后继符号集算法：</h3><ol>
<li>遍历文法所有的产生式，判断产生式右部中是否包含非终结符A</li>
<li>S -&gt; αAβ : 包含非终结符A，其中 α 和 β 都属于文法符号串，那么就将文法符号串β 的串首终结符集FIRST(β) 中除了空串ε外的所有终结符添加到FOLLOW(A)。如果FIRST(β)存在空串ε，那么就需要将FOLLOW(S) 也添加到FOLLOW(A)中。</li>
<li>S -&gt; αA : 包含非终结符A, 其中 α 属于文法符号串，那么将FOLLOW(S) 添加到FOLLOW(A)中。<br>如果非终结符 A 是产生式结尾，那么说明这个产生式左部非终结符后面能出现的终结符，也都可以出现在非终结符 A后面。</li>
<li>刚开始的时候，需要将结束符号 $ 添加到文法开始符号S 的后继符号集FOLLOW(S) 中。</li>
<li>后继符号集中是不会包含空串ε的。</li>
</ol>
<h2 id="可选集（Select"><a href="#可选集（Select" class="headerlink" title="可选集（Select)"></a>可选集（Select)</h2><ol>
<li>A→aβ : a 是终结符，β 是文法符号串，那么这个产生式的可选集SELECT(A→aβ) 就是这个终结符，即{a}。</li>
<li>A→ε : 空产生式对应的可选集SELECT(A→ε) 就是A的后继符号集，即 FOLLOW(A)。</li>
<li>A→Bβ : B 是非终结符，β 是文法符号串，那么这个产生式的可选集SELECT(A→Bβ) 就是文法符号串Bβ的串首终结符集，即FIRST(Bβ)。<br>注意，如果FIRST(Bβ)包含空串ε，即文法符号串Bβ能推导出空串ε，那么还要将Follow(A)添加到产生式对应的可选集中。</li>
</ol>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">编译原理</a>
                    
                      <a class="hover-with-bg" href="/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/">语法分析</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">编译原理</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/11/26/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">黑盒测试</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/11/18/SSM%E4%B8%8EMVC/">
                        <span class="hidden-mobile">SSM与MVC</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->

